<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QPDS - Quantitative Poker Decision System</title>
    <style>
        :root {
            color-scheme: dark;
            --bg-primary: #2d2b55;
            --bg-secondary: #1e1b48;
            --bg-tertiary: #160f3d;
            --accent-purple: #b362ff;
            --accent-cyan: #64f4ff;
            --accent-pink: #ff7edb;
            --accent-gold: #f7c548;
            --text-primary: #f8f7ff;
            --text-secondary: #c7c7ff;
            --text-muted: #9da1ff;
            --panel-border: rgba(137, 97, 255, 0.45);
            --panel-bg: rgba(29, 26, 66, 0.85);
            --chip-shadow: 0 18px 35px rgba(99, 72, 199, 0.45);
            --card-shadow: 0 12px 28px rgba(22, 14, 46, 0.6);
            --font-sans: 'Inter', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            --font-code: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'Operator Mono', Menlo, Monaco, 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background: radial-gradient(circle at top left, rgba(100, 244, 255, 0.18), rgba(179, 98, 255, 0.05) 45%, transparent 70%),
                        linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 55%, var(--bg-tertiary) 100%);
            min-height: 100vh;
            padding: 32px 28px 56px;
            color: var(--text-primary);
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background:
                radial-gradient(circle at 20% 15%, rgba(100, 244, 255, 0.18), transparent 45%),
                radial-gradient(circle at 80% 10%, rgba(255, 126, 219, 0.2), transparent 55%),
                radial-gradient(circle at 50% 80%, rgba(179, 98, 255, 0.22), transparent 60%);
            opacity: 0.9;
            pointer-events: none;
            z-index: -2;
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background-image: linear-gradient(115deg, rgba(255, 255, 255, 0.04) 0, rgba(255, 255, 255, 0.02) 40%, rgba(255, 255, 255, 0.05) 100%);
            mix-blend-mode: soft-light;
            opacity: 0.35;
            pointer-events: none;
            z-index: -1;
        }

        .app {
            max-width: 1280px;
            margin: 0 auto 40px auto;
            position: relative;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
            position: relative;
            padding: 14px 22px 20px;
            border-radius: 22px;
            background: linear-gradient(140deg, rgba(25, 21, 56, 0.78), rgba(46, 38, 98, 0.42));
            border: 1px solid rgba(158, 118, 255, 0.42);
            box-shadow: 0 26px 52px rgba(18, 12, 43, 0.55);
            overflow: hidden;
        }

        .app-header::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 15% 15%, rgba(100, 244, 255, 0.25), transparent 60%),
                        radial-gradient(circle at 85% 20%, rgba(255, 126, 219, 0.25), transparent 60%);
            opacity: 0.55;
            pointer-events: none;
        }

        .header-buttons {
            display: flex;
            gap: 12px;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .header-art {
            position: absolute;
            inset: -40px -80px auto auto;
            width: 360px;
            height: 240px;
            pointer-events: none;
            display: flex;
            justify-content: flex-end;
            align-items: flex-start;
            gap: 18px;
            transform: rotate(-6deg);
            opacity: 0.75;
            flex-wrap: wrap;
        }

        .chip {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.32), rgba(179, 98, 255, 0.82));
            border: 6px double rgba(255, 255, 255, 0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 2.1rem;
            text-shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
            box-shadow: var(--chip-shadow);
            animation: chipFloat 6s ease-in-out infinite;
        }

        .chip-ace {
            width: 120px;
            height: 120px;
            font-size: 2.4rem;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.45), rgba(100, 244, 255, 0.82));
            animation-delay: 0.5s;
        }

        .chip-heart {
            background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.35), rgba(255, 126, 219, 0.78));
            border-width: 5px;
            animation-delay: 1.5s;
        }

        .chip-diamond {
            background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.32), rgba(247, 197, 72, 0.8));
            border-width: 4px;
            animation-delay: 2.3s;
        }

        .chip-club {
            background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.3), rgba(179, 98, 255, 0.75));
            border-width: 4px;
            animation-delay: 3.1s;
        }

        @keyframes chipFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-14px) rotate(4deg); }
        }

        .settings-btn,
        .lang-toggle {
            padding: 10px 20px;
            border: 1px solid rgba(179, 98, 255, 0.35);
            border-radius: 999px;
            background: rgba(179, 98, 255, 0.16);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            backdrop-filter: blur(6px);
        }

        .settings-btn:hover,
        .lang-toggle:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 28px rgba(15, 16, 48, 0.45);
            border-color: rgba(100, 244, 255, 0.45);
        }

        .api-status {
            font-size: 0.85rem;
            color: rgba(247, 249, 252, 0.92);
            background: rgba(100, 244, 255, 0.12);
            border-radius: 999px;
            padding: 6px 12px;
            border: 1px solid rgba(100, 244, 255, 0.32);
        }

        .title-block {
            position: relative;
            z-index: 1;
        }

        .title-block h1 {
            font-size: 2.7rem;
            font-weight: 700;
            letter-spacing: 0.06em;
            color: var(--accent-cyan);
            text-shadow: 0 10px 24px rgba(100, 244, 255, 0.28);
        }

        .title-block p {
            margin-top: 6px;
            font-size: 1.05rem;
            color: var(--text-muted);
            opacity: 0.9;
        }

        .layout {
            display: grid;
            grid-template-columns: minmax(320px, 0.95fr) minmax(0, 1.25fr);
            gap: 22px;
        }

        .panel {
            background: linear-gradient(165deg, rgba(30, 41, 59, 0.88), rgba(15, 23, 42, 0.96));
            backdrop-filter: blur(16px);
            border-radius: 22px;
            padding: 24px 26px;
            border: 1px solid rgba(148, 163, 184, 0.22);
            box-shadow: 0 26px 52px rgba(15, 23, 42, 0.5);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            inset: 1.5px;
            border-radius: 20px;
            border: 1px solid rgba(100, 244, 255, 0.08);
            pointer-events: none;
        }

        .panel::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top right, rgba(255, 126, 219, 0.14), transparent 60%),
                        radial-gradient(circle at bottom left, rgba(100, 244, 255, 0.12), transparent 55%);
            opacity: 0.35;
            pointer-events: none;
        }

        .panel h2 {
            font-size: 1.42rem;
            margin-bottom: 20px;
            color: #e0f2fe;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 0.04em;
        }

        .panel h2::before {
            content: 'â™ ';
            font-size: 1.45rem;
            color: var(--accent-purple);
            text-shadow: 0 0 12px rgba(179, 98, 255, 0.6);
        }

        #lessonPanel > h2::before { content: 'â™£'; color: var(--accent-pink); }
        #statePanel > h2::before { content: 'â™ '; }
        #deckPanel > h2::before { content: 'â™¦'; color: var(--accent-gold); }

        .lesson-list {
            display: grid;
            gap: 12px;
            margin-top: 16px;
        }

        .lesson-item {
            background: rgba(37, 33, 74, 0.55);
            border-radius: 14px;
            padding: 16px 18px;
            border-left: 4px solid rgba(179, 98, 255, 0.8);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .game-manual-btn {
            padding: 10px 20px;
            border: 1px solid rgba(255, 126, 219, 0.4);
            border-radius: 999px;
            background: rgba(255, 126, 219, 0.18);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            backdrop-filter: blur(6px);
        }

        .game-manual-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 18px 32px rgba(78, 15, 86, 0.45);
            border-color: rgba(255, 126, 219, 0.6);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
        }

        .modal-overlay.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #374785, #243B55);
            border-radius: 16px;
            padding: 30px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            margin: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            color: #f7f9fc;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 16px;
        }

        .modal-title {
            font-size: 2rem;
            font-weight: 700;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: #f7f9fc;
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .manual-section {
            margin-bottom: 24px;
        }

        .manual-section h3 {
            font-size: 1.3rem;
            margin-bottom: 12px;
            color: #8ec5fc;
        }

        .manual-section p, .manual-section li {
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .manual-section ul {
            padding-left: 20px;
        }

        .hand-rankings {
            display: grid;
            gap: 12px;
        }

        .hand-rank {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hand-rank-name {
            font-weight: 600;
        }

        .hand-rank-example {
            font-family: monospace;
            color: #8ec5fc;
        }

        .position-categories {
            margin: 16px 0;
        }

        .position-category {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            border-left: 4px solid #8ec5fc;
        }

        .position-category h4 {
            margin: 0 0 12px 0;
            color: #8ec5fc;
            font-size: 1.1rem;
        }

        .position-category ul {
            margin: 0;
            padding-left: 20px;
        }

        .position-category li {
            margin-bottom: 8px;
        }

        .position-tips {
            background: rgba(142, 197, 252, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-top: 20px;
        }

        .position-tips h4 {
            margin: 0 0 12px 0;
            color: #8ec5fc;
        }

        .position-tips ul {
            margin: 0;
            padding-left: 20px;
        }

        .position-tips li {
            margin-bottom: 8px;
        }

        .beginner-tip {
            background: linear-gradient(135deg, rgba(142, 197, 252, 0.15), rgba(68, 189, 50, 0.1));
            border: 2px solid rgba(142, 197, 252, 0.3);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 24px;
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(142, 197, 252, 0.3); }
            to { box-shadow: 0 0 20px rgba(142, 197, 252, 0.6); }
        }

        .beginner-tip h3 {
            margin: 0 0 12px 0;
            color: #8ec5fc;
            font-size: 1.2rem;
        }

        .beginner-steps {
            margin: 12px 0;
            padding-left: 20px;
            line-height: 1.6;
        }

        .beginner-steps li {
            margin-bottom: 8px;
            color: #f0f4ff;
        }

        .dismiss-tip {
            background: rgba(142, 197, 252, 0.2);
            border: 1px solid rgba(142, 197, 252, 0.4);
            color: #f0f4ff;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 12px;
            transition: all 0.2s ease;
        }

        .dismiss-tip:hover {
            background: rgba(142, 197, 252, 0.3);
            transform: translateY(-1px);
        }

        .beginner-tip.hidden {
            display: none;
        }

        .hand-categories {
            margin: 16px 0;
        }

        .hand-category {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .hand-category.premium {
            border-left: 4px solid #4CAF50;
        }

        .hand-category.strong {
            border-left: 4px solid #FF9800;
        }

        .hand-category.speculative {
            border-left: 4px solid #2196F3;
        }

        .hand-category h4 {
            margin: 0 0 12px 0;
            font-size: 1rem;
        }

        .hand-examples {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .hand-example {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: monospace;
            font-weight: 600;
            font-size: 0.9rem;
            color: #8ec5fc;
        }

        .hand-tips {
            background: rgba(142, 197, 252, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
        }

        .hand-tips p {
            margin: 0;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .lesson-item strong {
            display: block;
            font-size: 0.95rem;
            margin-bottom: 6px;
        }

        .lesson-item span {
            font-size: 0.92rem;
            opacity: 0.9;
            line-height: 1.5;
        }

        .cheatsheet {
            margin-top: 22px;
            padding: 18px 20px;
            border-radius: 18px;
            background: rgba(25, 23, 60, 0.65);
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        }

        .cheatsheet h3 {
            font-size: 1.02rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-secondary);
            margin-bottom: 16px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .cheatsheet h3::before {
            content: 'â™£';
            font-size: 1.2rem;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px rgba(100, 244, 255, 0.55);
        }

        .cheatsheet-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 18px;
        }

        .cheatsheet-card {
            background: rgba(20, 18, 48, 0.72);
            border-radius: 14px;
            padding: 16px;
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        }

        .cheatsheet-label {
            font-size: 0.9rem;
            color: var(--accent-purple);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 10px;
        }

        .cheatsheet-card ul {
            margin: 0;
            padding-left: 18px;
            display: grid;
            gap: 8px;
        }

        .cheatsheet-card li {
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.45;
        }

        .section {
            margin-bottom: 18px;
        }

        .section h3 {
            font-size: 1.08rem;
            margin-bottom: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .section h3::before {
            content: 'â™¦';
            font-size: 1.2rem;
            color: var(--accent-pink);
            text-shadow: 0 0 10px rgba(255, 126, 219, 0.55);
        }

        .stage-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 10px;
            margin-bottom: 18px;
        }

        .stage-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(29, 27, 68, 0.6);
            border-radius: 12px;
            padding: 10px 14px;
            cursor: pointer;
            transition: background 0.2s ease, border 0.2s ease;
            font-size: 0.92rem;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .stage-options label:hover {
            border-color: rgba(100, 244, 255, 0.35);
        }

        .stage-options input[type="radio"] {
            accent-color: var(--accent-purple);
        }

        .stage-options label.active {
            background: linear-gradient(140deg, rgba(179, 98, 255, 0.28), rgba(100, 244, 255, 0.22));
            border: 1px solid rgba(100, 244, 255, 0.45);
        }

        .card-slots {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(78px, 1fr));
            gap: 12px;
        }

        .card-slot {
            position: relative;
            border-radius: 16px;
            min-height: 110px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.45rem;
            color: rgba(255, 255, 255, 0.68);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease;
            background: linear-gradient(155deg, rgba(45, 43, 85, 0.65), rgba(24, 18, 52, 0.85));
            border: 1px solid rgba(148, 163, 184, 0.22);
            box-shadow: var(--card-shadow);
        }

        .card-slot[data-disabled="true"] {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .card-slot[data-selected="true"] {
            border-color: rgba(100, 244, 255, 0.65);
            background: linear-gradient(160deg, rgba(100, 244, 255, 0.18), rgba(94, 53, 156, 0.55));
            transform: translateY(-4px);
            box-shadow: 0 18px 32px rgba(21, 13, 52, 0.55);
        }

        .card-slot .card-label {
            position: absolute;
            top: 6px;
            left: 8px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: rgba(255, 255, 255, 0.55);
        }

        .card-slot .remove-tag {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(179, 98, 255, 0.22);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.85);
        }

        .card-slot[data-filled="true"] {
            border-color: rgba(255, 126, 219, 0.45);
            background: linear-gradient(160deg, rgba(255, 241, 255, 0.14), rgba(122, 87, 244, 0.45));
            color: #fff;
            font-weight: 600;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
        }

        .card-slot[data-filled="true"] .remove-tag {
            cursor: pointer;
        }

        .inputs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
        }

        label.field-label {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.85rem;
            opacity: 0.85;
            letter-spacing: 0.04em;
        }

        input[type="number"],
        input[type="text"],
        select {
            background: rgba(31, 28, 66, 0.75);
            border: 1px solid rgba(148, 163, 184, 0.28);
            border-radius: 12px;
            padding: 11px 14px;
            color: var(--text-primary);
            font-size: 0.96rem;
            font-family: var(--font-code);
            letter-spacing: 0.01em;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        input::placeholder,
        select option {
            color: rgba(255, 255, 255, 0.6);
        }

        select {
            cursor: pointer;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            border-color: rgba(100, 244, 255, 0.55);
            box-shadow: 0 0 0 3px rgba(100, 244, 255, 0.2);
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-top: 10px;
        }

        .slider-row span {
            font-size: 0.82rem;
            opacity: 0.75;
        }

        .slider-row strong {
            font-size: 0.95rem;
            color: #f1f5ff;
        }

        input[type="range"] {
            flex: 1;
            accent-color: var(--accent-purple);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 20px;
        }

        .button-group button {
            flex: 1 1 180px;
            padding: 12px 16px;
            border: 1px solid rgba(179, 98, 255, 0.35);
            border-radius: 14px;
            font-size: 0.96rem;
            font-weight: 600;
            cursor: pointer;
            color: var(--text-primary);
            background: linear-gradient(135deg, rgba(179, 98, 255, 0.38), rgba(100, 244, 255, 0.2));
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            backdrop-filter: blur(6px);
        }

        .button-group button:hover {
            transform: translateY(-3px);
            box-shadow: 0 18px 36px rgba(21, 17, 56, 0.55);
            border-color: rgba(100, 244, 255, 0.45);
        }

        .button-group .ghost {
            background: rgba(37, 33, 74, 0.55);
            color: var(--text-muted);
            border-color: rgba(148, 163, 184, 0.25);
        }

        .deck-panel {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .deck-grid {
            display: grid;
            gap: 10px;
            padding: 12px 14px;
            background: rgba(21, 19, 48, 0.6);
            border-radius: 18px;
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            overflow-x: auto;
        }

        .deck-row {
            display: grid;
            grid-template-columns: 48px repeat(13, minmax(44px, 1fr));
            gap: 8px;
            align-items: center;
            padding: 6px 0;
        }

        .deck-suit {
            justify-self: center;
            font-size: 1.4rem;
            color: var(--accent-cyan);
            text-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            opacity: 0.9;
        }

        .deck-row[data-suit="hearts"] .deck-suit { color: #ff7d9c; }
        .deck-row[data-suit="diamonds"] .deck-suit { color: var(--accent-gold); }
        .deck-row[data-suit="clubs"] .deck-suit { color: var(--accent-purple); }

        .card-button {
            border: 1px solid rgba(148, 163, 184, 0.22);
            border-radius: 10px;
            padding: 10px 6px;
            font-size: 0.96rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease, border-color 0.15s ease;
            background: linear-gradient(150deg, rgba(45, 43, 85, 0.9), rgba(28, 20, 58, 0.85));
            color: var(--text-primary);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            font-family: var(--font-code);
            justify-self: center;
        }

        .card-button[data-suit="hearts"],
        .card-button[data-suit="diamonds"] {
            color: #ff7d9c;
        }

        .card-button[data-suit="spades"],
        .card-button[data-suit="clubs"] {
            color: #64f4ff;
        }

        .card-button:hover {
            transform: translateY(-3px);
            border-color: rgba(100, 244, 255, 0.35);
            box-shadow: 0 15px 26px rgba(19, 12, 44, 0.45);
        }

        .card-button[data-used="true"] {
            filter: saturate(0.3) brightness(0.7);
            opacity: 0.4;
            cursor: not-allowed;
        }

        .analysis-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .result-banner {
            background: linear-gradient(135deg, rgba(45, 43, 85, 0.9), rgba(24, 18, 52, 0.85));
            border-radius: 18px;
            padding: 22px;
            text-align: center;
            color: var(--text-primary);
            border: 1px solid rgba(100, 244, 255, 0.28);
            box-shadow: 0 24px 48px rgba(12, 9, 32, 0.55);
        }

        .result-banner .action-label {
            font-size: 0.9rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .result-banner .action-value {
            font-size: 2rem;
            font-weight: 700;
            margin-top: 8px;
            text-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        }

        .result-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 12px;
            text-align: left;
        }

        .result-detail {
            background: rgba(37, 33, 74, 0.65);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(148, 163, 184, 0.18);
        }

        .result-detail span {
            display: block;
            font-size: 0.78rem;
            letter-spacing: 0.08em;
            opacity: 0.68;
            text-transform: uppercase;
        }

        .result-detail strong {
            display: block;
            margin-top: 4px;
            font-size: 1.05rem;
            color: var(--accent-cyan);
        }

        .explanation-box {
            background: rgba(32, 30, 70, 0.72);
            border-radius: 14px;
            padding: 16px;
            font-size: 0.94rem;
            line-height: 1.6;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            color: var(--text-secondary);
        }

        .factors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
        }

        .factor-card {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 14px;
            padding: 16px;
            border: 1px solid rgba(148, 163, 184, 0.14);
            box-shadow: inset 0 0 0 1px rgba(34, 211, 238, 0.04);
        }

        .factor-card .factor-name {
            font-size: 0.75rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            opacity: 0.68;
        }

        .factor-card .factor-value {
            font-size: 1.2rem;
            font-weight: 600;
            margin-top: 6px;
            color: #e0f2fe;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 14px;
            margin-top: 18px;
        }

        .summary-item {
            background: rgba(15, 23, 42, 0.58);
            border-radius: 12px;
            padding: 14px;
            border: 1px solid rgba(148, 163, 184, 0.12);
        }

        .summary-item span {
            display: block;
            font-size: 0.78rem;
            letter-spacing: 0.08em;
            opacity: 0.7;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .summary-item strong {
            display: block;
            margin-top: 4px;
            font-size: 1.05rem;
            color: var(--accent-cyan);
        }

        .opponent-section {
            margin-top: 28px;
            padding: 20px;
            border-radius: 18px;
            background: rgba(30, 41, 59, 0.75);
            border: 1px solid rgba(148, 163, 184, 0.18);
        }

        .opponent-section h3 {
            margin-bottom: 16px;
            font-size: 1.1rem;
            color: #bae6fd;
        }

        .opponent-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
        }

        .metric-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(15, 23, 42, 0.65);
            border: 1px solid rgba(148, 163, 184, 0.12);
        }

        .metric-group span {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .metric-group input[type="range"] {
            width: 100%;
        }

        .metric-group input[type="number"],
        .metric-group select,
        .metric-group textarea {
            width: 100%;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            resize: vertical;
        }

        .metric-group textarea {
            min-height: 64px;
        }

        .metric-range-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .insights-panel {
            margin-top: 24px;
            padding: 20px;
            border-radius: 18px;
            background: rgba(15, 76, 129, 0.18);
            border: 1px solid rgba(56, 189, 248, 0.25);
        }

        .insights-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 16px;
        }

        .archetype-pill {
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(56, 189, 248, 0.2);
            color: #bae6fd;
            font-weight: 600;
            font-size: 0.88rem;
        }

        .insight-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 14px;
        }

        .insight-card {
            padding: 14px;
            border-radius: 14px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.16);
        }

        .insight-card strong {
            display: block;
            margin-bottom: 6px;
            color: #e0f2fe;
        }

        .insight-notes {
            margin-top: 16px;
            display: grid;
            gap: 8px;
        }

        .insight-note {
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(30, 58, 138, 0.25);
            border: 1px solid rgba(59, 130, 246, 0.28);
            font-size: 0.88rem;
            line-height: 1.4;
        }

        .loading {
            display: none;
            justify-content: center;
            align-items: center;
            gap: 12px;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .loading.active {
            display: flex;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.15);
            border-top: 4px solid #8ec5fc;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-box {
            background: linear-gradient(135deg, rgba(214, 69, 65, 0.22), rgba(122, 38, 69, 0.28));
            border: 1px solid rgba(214, 69, 65, 0.45);
            border-radius: 14px;
            padding: 14px 16px;
            font-size: 0.9rem;
            line-height: 1.5;
            display: none;
            color: #ffeaf1;
            box-shadow: 0 18px 32px rgba(78, 15, 29, 0.35);
        }

        .error-box.active {
            display: block;
        }

        @media (max-width: 1024px) {
            .layout {
                grid-template-columns: 1fr;
            }

            .deck-panel {
                order: 3;
            }
        }

        @media (max-width: 640px) {
            body {
                padding: 16px;
            }

            .app-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .header-art {
                display: none;
            }

            .button-group button {
                flex: 1 1 100%;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <div class="title-block">
                <h1 data-i18n="title">QPDS</h1>
                <p data-i18n="subtitle">é‡åŒ–å¾·å·æ‰‘å…‹å†³ç­–è¾…åŠ©ç³»ç»Ÿ</p>
            </div>
            <div class="header-buttons">
                <button class="game-manual-btn" id="gameManualBtn" data-i18n="buttons.gameManual">ğŸƒ æ¸¸æˆæ‰‹å†Œ</button>
                <button id="apiConfigBtn" class="settings-btn" data-i18n="buttons.apiConfig">âš™ï¸ API</button>
                <button id="langToggle" class="lang-toggle">English</button>
                <span class="api-status" id="apiStatusLabel"></span>
            </div>
            <div class="header-art" aria-hidden="true">
                <div class="chip chip-ace">Aâ™ </div>
                <div class="chip chip-heart">â™¥</div>
                <div class="chip chip-diamond">â™¦</div>
                <div class="chip chip-club">â™£</div>
            </div>
        </header>

        <div class="layout">
            <section class="panel" id="lessonPanel">
                <h2 data-i18n="lesson.heading">æ— é™æ³¨å¾·å·æ‰‘å…‹ï¼šè§„åˆ™é€Ÿè§ˆ</h2>

                <div class="beginner-tip" id="beginnerTip">
                    <h3 data-i18n="beginner.title">ğŸš€ æ–°æ‰‹å¿«é€Ÿå…¥é—¨</h3>
                    <div class="tip-content">
                        <p data-i18n="beginner.intro">ç¬¬ä¸€æ¬¡ä½¿ç”¨ï¼ŸæŒ‰ä»¥ä¸‹æ­¥éª¤å¼€å§‹ï¼š</p>
                        <ol class="beginner-steps">
                            <li data-i18n="beginner.step1">é€‰æ‹©åº•ç‰Œï¼šç‚¹å‡»å·¦è¾¹"ä½ çš„åº•ç‰Œ"åŒºåŸŸçš„ç©ºæ§½ï¼Œç„¶åä»ä¸‹æ–¹ç‰Œå †é€‰æ‹©ä¸¤å¼ ç‰Œ</li>
                            <li data-i18n="beginner.step2">è®¾ç½®é˜¶æ®µï¼šé€‰æ‹©å½“å‰æ¸¸æˆé˜¶æ®µï¼ˆå»ºè®®æ–°æ‰‹ä»"ç¿»å‰"å¼€å§‹ï¼‰</li>
                            <li data-i18n="beginner.step3">è¾“å…¥å‚æ•°ï¼šè®¾ç½®åº•æ± 100ã€è·Ÿæ³¨20ã€åŒæ–¹ç­¹ç å„500</li>
                            <li data-i18n="beginner.step4">é€‰æ‹©ä½ç½®ï¼šå¦‚ä¸ç¡®å®šé€‰æ‹©"æŒ‰é’®ä½(BTN)"</li>
                            <li data-i18n="beginner.step5">è·å–å»ºè®®ï¼šç‚¹å‡»"è·å–å†³ç­–å»ºè®®"æŸ¥çœ‹æ¨èè¡ŒåŠ¨</li>
                        </ol>
                        <button class="dismiss-tip" id="dismissTip" data-i18n="beginner.dismiss">æˆ‘çŸ¥é“äº†</button>
                    </div>
                </div>

                <div class="lesson-list">
                    <div class="lesson-item">
                        <strong data-i18n="lesson.goal.title">æ ¸å¿ƒç›®æ ‡</strong>
                        <span data-i18n="lesson.goal.copy">é€šè¿‡æ‘Šç‰Œèµ¢å¾—æœ€å¤§æˆæ‰‹ç‰Œï¼Œæˆ–è®©æ‰€æœ‰å¯¹æ‰‹å¼ƒç‰Œï¼Œå¤ºå–åº•æ± ã€‚</span>
                    </div>
                    <div class="lesson-item">
                        <strong data-i18n="lesson.structure.title">ä¸€å±€æµç¨‹</strong>
                        <span data-i18n="lesson.structure.copy">ä¸¤å¼ åº•ç‰Œèµ·æ‰‹ï¼Œç›²æ³¨åšåº•ï¼Œå…¬å…±ç‰Œä¾æ¬¡ç¿»ç‰Œåœˆã€è½¬ç‰Œåœˆã€æ²³ç‰Œåœˆäº®å‡ºï¼Œæœ€å¤šå››è½®ä¸‹æ³¨ã€‚</span>
                    </div>
                    <div class="lesson-item">
                        <strong data-i18n="lesson.position.title">ä½ç½®ä¸ä¿¡æ¯</strong>
                        <span data-i18n="lesson.position.copy">æŒ‰é’®ä½æœ€åè¡ŒåŠ¨ä¼˜åŠ¿æœ€å¤§ï¼Œç›²æ³¨ä½ç½®ç¿»ç‰Œåéœ€ç‡å…ˆè¡ŒåŠ¨ã€‚</span>
                    </div>
                    <div class="lesson-item">
                        <strong data-i18n="lesson.strategy.title">é‡åŒ–æ€ç»´</strong>
                        <span data-i18n="lesson.strategy.copy">èƒœç‡ã€åº•æ± èµ”ç‡ã€é£é™©åå¥½å…±åŒé©±åŠ¨å†³ç­–ï¼Œä¿æŒçºªå¾‹ï¼Œé¿å…æƒ…ç»ªåŒ–ã€‚</span>
                    </div>
                </div>

                <div class="cheatsheet">
                    <h3 data-i18n="lesson.cheatsheet.title">ç‰Œæ¡Œé€ŸæŸ¥å®å…¸</h3>
                    <div class="cheatsheet-grid">
                        <div class="cheatsheet-card">
                            <div class="cheatsheet-label" data-i18n="lesson.cheatsheet.preflop">ç¿»å‰å£ä»¤</div>
                            <ul>
                                <li data-i18n="lesson.cheatsheet.preflop1">æŒ‰é’®ä½ 3x å¼€å±€ï¼Œå®½æ¾å·ç›²</li>
                                <li data-i18n="lesson.cheatsheet.preflop2">å‰ä½ç´§å‡¶ï¼šé¡¶çº§å¯¹å­ + å¼ºåŒèŠ±è¿ç‰Œ</li>
                                <li data-i18n="lesson.cheatsheet.preflop3">å¤§ç›²é˜²å®ˆï¼šèµ”ç‡ â‰¥ 3:1 æ‰è·Ÿæ³¨</li>
                            </ul>
                        </div>
                        <div class="cheatsheet-card">
                            <div class="cheatsheet-label" data-i18n="lesson.cheatsheet.flop">ç¿»ç‰Œè¯»ç‰Œ</div>
                            <ul>
                                <li data-i18n="lesson.cheatsheet.flop1">å¹²ç‡¥æ¿ï¼šä¸­ç­‰å¯¹å­å¯æŒç»­ä¸‹æ³¨</li>
                                <li data-i18n="lesson.cheatsheet.flop2">æ¹¿æ¶¦æ¿ï¼šä¼˜å…ˆä¿æŠ¤ï¼Œå‡å°ä¸‹æ³¨å°ºåº¦</li>
                                <li data-i18n="lesson.cheatsheet.flop3">ä¸­é¡º/åŒèŠ±å¬ç‰Œï¼šè®¡ç®—è¡¥ç‰Œ Ã—4 æ¦‚ç‡</li>
                            </ul>
                        </div>
                        <div class="cheatsheet-card">
                            <div class="cheatsheet-label" data-i18n="lesson.cheatsheet.turn">è½¬ç‰Œå†³ç­–</div>
                            <ul>
                                <li data-i18n="lesson.cheatsheet.turn1">SPR &lt; 1.5ï¼šç‰ŒåŠ›å¤Ÿå¼ºå¯ç›´æ¥æŠ•å…¥</li>
                                <li data-i18n="lesson.cheatsheet.turn2">å¯¹æ‰‹åŠ æ³¨ => è¯„ä¼°èŒƒå›´ä¼˜åŠ¿æ˜¯å¦åè½¬</li>
                                <li data-i18n="lesson.cheatsheet.turn3">åŠè¯ˆå”¬éœ€ä¿è¯å¼ƒç‰Œç‡ Ã— åº•æ±  â‰¥ æˆæœ¬</li>
                            </ul>
                        </div>
                        <div class="cheatsheet-card">
                            <div class="cheatsheet-label" data-i18n="lesson.cheatsheet.river">æ²³ç‰Œæ‰§è¡Œ</div>
                            <ul>
                                <li data-i18n="lesson.cheatsheet.river1">ä»·å€¼ä¸‹æ³¨ï¼šèƒ½è¢«æ›´å·®çš„ç‰Œè·Ÿæ³¨ï¼Ÿ</li>
                                <li data-i18n="lesson.cheatsheet.river2">ç²¾å‡†è¯ˆå”¬ï¼šä»£è¡¨å¼ºç‰Œ + é˜»æ–­å¯¹æ‰‹å…³é”®ç‰Œ</li>
                                <li data-i18n="lesson.cheatsheet.river3">é”™è¿‡å¬ç‰Œ â†’ æƒè¡¡å¼ƒç‰Œç‡ / æ‘Šç‰Œä»·å€¼</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <section class="panel" id="statePanel">
                <div class="section">
                    <h2 data-i18n="state.heading">ç‰Œå±€è®¾ç½®</h2>
                    <div class="stage-options" id="streetOptions">
                        <label data-street="PREFLOP" class="active">
                            <input type="radio" name="street" value="PREFLOP" checked>
                            <span data-i18n="streets.PREFLOP">ç¿»å‰ (Preflop)</span>
                        </label>
                        <label data-street="FLOP">
                            <input type="radio" name="street" value="FLOP">
                            <span data-i18n="streets.FLOP">ç¿»ç‰Œåœˆ (Flop)</span>
                        </label>
                        <label data-street="TURN">
                            <input type="radio" name="street" value="TURN">
                            <span data-i18n="streets.TURN">è½¬ç‰Œåœˆ (Turn)</span>
                        </label>
                        <label data-street="RIVER">
                            <input type="radio" name="street" value="RIVER">
                            <span data-i18n="streets.RIVER">æ²³ç‰Œåœˆ (River)</span>
                        </label>
                    </div>
                </div>

                <div class="section">
                    <h3 data-i18n="state.hero">ä½ çš„åº•ç‰Œ</h3>
                    <div class="card-slots" id="heroSlots"></div>
                </div>

                <div class="section">
                    <h3 data-i18n="state.board">å…¬å…±ç‰Œ</h3>
                    <div class="card-slots" id="boardSlots"></div>
                </div>

                <div class="section">
                    <h3 data-i18n="state.parameters">ç­¹ç ä¸å‚æ•°</h3>
                    <div class="inputs-grid">
                        <label class="field-label">
                            <span data-i18n="fields.pot">åº•æ± å¤§å°</span>
                            <input type="number" id="potInput" min="0" step="0.01" value="100" data-i18n-placeholder="placeholders.pot">
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.toCall">éœ€è¦è·Ÿæ³¨</span>
                            <input type="number" id="toCallInput" min="0" step="0.01" value="10" data-i18n-placeholder="placeholders.toCall">
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.heroStack">ä½ çš„ç­¹ç </span>
                            <input type="number" id="heroStackInput" min="0" step="0.01" value="500" data-i18n-placeholder="placeholders.heroStack">
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.villainStack">å¯¹æ‰‹ç­¹ç </span>
                            <input type="number" id="villainStackInput" min="0" step="0.01" value="500" data-i18n-placeholder="placeholders.villainStack">
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.position">ä½ çš„ä½ç½®</span>
                            <select id="positionSelect"></select>
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.villainRange">å¯¹æ‰‹èŒƒå›´</span>
                            <input type="text" id="rangeInput" data-i18n-placeholder="placeholders.villainRange" placeholder="AA,KK,QQ,AKs">
                        </label>
                    </div>

                    <div class="slider-row">
                        <span data-i18n="risk.conservative">ä¿å®ˆ</span>
                        <input type="range" id="riskSlider" min="0" max="10" value="5">
                        <span data-i18n="risk.aggressive">æ¿€è¿›</span>
                        <strong id="riskValue">5</strong>
                    </div>
                </div>

                <div class="opponent-section" id="opponentSection">
                    <h3 data-i18n="opponent.heading">å¯¹æ‰‹å»ºæ¨¡</h3>
                    <div class="opponent-grid">
                        <div class="metric-group">
                            <span data-i18n="opponent.aggression.label">æ¿€è¿›ç¨‹åº¦</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.aggression.low">è¢«åŠ¨</small>
                                <small id="opAggressionValue">6/10</small>
                                <small data-i18n="opponent.aggression.high">æ¿€è¿›</small>
                            </div>
                            <input type="range" id="opAggressionInput" min="0" max="10" value="6">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.tightness.label">èµ·æ‰‹èŒƒå›´</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.tightness.wide">å®½æ¾</small>
                                <small id="opTightnessValue">5/10</small>
                                <small data-i18n="opponent.tightness.narrow">ç´§å®</small>
                            </div>
                            <input type="range" id="opTightnessInput" min="0" max="10" value="5">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.bluff.label">è¯ˆå”¬é¢‘ç‡</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.bluff.low">ç½•è§</small>
                                <small id="opBluffValue">3/10</small>
                                <small data-i18n="opponent.bluff.high">é¢‘ç¹</small>
                            </div>
                            <input type="range" id="opBluffInput" min="0" max="10" value="3">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.confidence.label">å¯¹æ‰‹è‡ªä¿¡</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.confidence.low">çŠ¹è±«</small>
                                <small id="opConfidenceValue">6/10</small>
                                <small data-i18n="opponent.confidence.high">è‡ªä¿¡</small>
                            </div>
                            <input type="range" id="opConfidenceInput" min="0" max="10" value="6">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.tilt.label">æƒ…ç»ªæ³¢åŠ¨</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.tilt.calm">å†·é™</small>
                                <small id="opTiltValue">4/10</small>
                                <small data-i18n="opponent.tilt.hot">å€¾å‘å¤±æ§</small>
                            </div>
                            <input type="range" id="opTiltInput" min="0" max="10" value="4">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.bet.label">æœ€è¿‘ä¸‹æ³¨å åº•æ± %</span>
                            <input type="number" id="opBetPctInput" min="0" max="400" step="1" value="65" data-i18n-placeholder="opponent.bet.placeholder" placeholder="ä¾‹å¦‚ 70">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.action.label">æœ€è¿‘åŠ¨ä½œ</span>
                            <select id="opActionStreet">
                                <option value="PREFLOP" data-i18n="streets.PREFLOP">ç¿»å‰ (Preflop)</option>
                                <option value="FLOP" data-i18n="streets.FLOP">ç¿»ç‰Œåœˆ (Flop)</option>
                                <option value="TURN" data-i18n="streets.TURN">è½¬ç‰Œåœˆ (Turn)</option>
                                <option value="RIVER" data-i18n="streets.RIVER">æ²³ç‰Œåœˆ (River)</option>
                            </select>
                            <select id="opActionType">
                                <option value="bet" data-i18n="opponent.action.bet">ä¸‹æ³¨</option>
                                <option value="raise" data-i18n="opponent.action.raise">åŠ æ³¨</option>
                                <option value="call" data-i18n="opponent.action.call">è·Ÿæ³¨</option>
                                <option value="check" data-i18n="opponent.action.check">è¿‡ç‰Œ</option>
                            </select>
                            <input type="number" id="opActionAmount" min="0" step="0.01" data-i18n-placeholder="opponent.action.amount" placeholder="ä¾‹å¦‚ 80">
                            <input type="number" id="opActionPot" min="0" step="0.01" data-i18n-placeholder="opponent.action.pot" placeholder="è¡ŒåŠ¨å‰åº•æ± ">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.notes.label">é¢å¤–å¤‡æ³¨</span>
                            <textarea id="opNotesInput" data-i18n-placeholder="opponent.notes.placeholder" placeholder="ä¾‹å¦‚ï¼šç¿»ç‰ŒåœˆæŒç»­ä¸‹æ³¨ï¼Œæ²³ç‰Œç´§å‡¶"></textarea>
                        </div>
                    </div>
                </div>

                <div class="button-group">
                    <button id="recommendButton" data-i18n="buttons.recommend">è·å–å†³ç­–å»ºè®®</button>
                    <button id="equityButton" data-i18n="buttons.equity">ä»…è®¡ç®—èƒœç‡</button>
                    <button id="resetButton" class="ghost" data-i18n="buttons.reset">é‡ç½®ç‰Œé¢</button>
                </div>

                <div class="error-box" id="errorBox"></div>
            </section>

            <section class="panel deck-panel" id="deckPanel">
                <div>
                    <h2 data-i18n="deck.heading">ç‰Œå † (ç‚¹å‡»é€‰æ‹©å¡ç‰Œ)</h2>
                    <p data-i18n="deck.hint" style="font-size:0.9rem;opacity:0.75;line-height:1.5;margin-top:6px;">
                        å…ˆç‚¹å‡»ç©ºæ§½å†ç‚¹é€‰å¡ç‰Œï¼›å·²é€‰å¡ç‰Œä¼šè‡ªåŠ¨ç°åŒ–ï¼Œç‚¹å‡»æ§½ä½å³ä¸Šè§’å¯æ¸…é™¤ã€‚
                    </p>
                </div>
                <div class="deck-grid" id="deckGrid"></div>
            </section>

            <section class="panel analysis-panel" id="analysisPanel">
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <span data-i18n="loading">æ­£åœ¨ä¸ºä½ é‡åŒ–ç‰Œå±€...</span>
                </div>

                <div class="result-banner" id="resultBanner" style="display: none;">
                    <div class="action-label" data-i18n="result.action">æ¨èè¡ŒåŠ¨</div>
                    <div class="action-value" id="actionValue">-</div>
                    <div class="result-details">
                        <div class="result-detail">
                            <span data-i18n="result.confidence">ç½®ä¿¡åº¦</span>
                            <strong id="confidenceValue">-</strong>
                        </div>
                        <div class="result-detail">
                            <span data-i18n="result.ev">é¢„æœŸç›ˆåˆ©</span>
                            <strong id="evValue">-</strong>
                        </div>
                    </div>
                </div>

                <div class="explanation-box" id="explanationBox" style="display: none;"></div>

                <div class="insights-panel" id="opponentInsights" style="display: none;">
                    <div class="insights-header">
                        <h3 data-i18n="opponent.insights.heading">å¯¹æ‰‹ç”»åƒ</h3>
                        <span class="archetype-pill" id="opponentArchetype"></span>
                    </div>
                    <p id="opponentSummary" style="font-size:0.92rem;line-height:1.6;opacity:0.82;margin-bottom:16px;"></p>
                    <div class="insight-cards">
                        <div class="insight-card">
                            <strong data-i18n="opponent.insights.aggression">æ¿€è¿›æŒ‡æ•°</strong>
                            <span id="opponentAggressionMetric">-</span>
                        </div>
                        <div class="insight-card">
                            <strong data-i18n="opponent.insights.betting">ä¸‹æ³¨å‹åŠ›</strong>
                            <span id="opponentBettingMetric">-</span>
                        </div>
                        <div class="insight-card">
                            <strong data-i18n="opponent.insights.psychology">å¿ƒç†å‹å¼º</strong>
                            <span id="opponentPsychologyMetric">-</span>
                        </div>
                        <div class="insight-card">
                            <strong data-i18n="opponent.insights.range">èŒƒå›´ä¼˜åŠ¿</strong>
                            <span id="opponentRangeMetric">-</span>
                        </div>
                    </div>
                    <div class="insight-notes" id="opponentNotes"></div>
                </div>

                <div>
                    <h3 data-i18n="summary.heading">å½“å‰è¾“å…¥æ¦‚è§ˆ</h3>
                    <div class="summary-grid" id="summaryGrid"></div>
                </div>

                <div>
                    <h3 data-i18n="factors.heading">å…³é”®å› å­</h3>
                    <div class="factors-grid" id="factorsGrid"></div>
                </div>
            </section>
        </div>
    </div>

    <!-- æ¸¸æˆæ‰‹å†Œæ¨¡æ€æ¡† -->
    <div class="modal-overlay" id="gameManualModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" data-i18n="manual.title">å¾·å·æ‰‘å…‹æ¸¸æˆæ‰‹å†Œ</h2>
                <button class="modal-close" id="closeManualBtn">&times;</button>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.basicRules">åŸºæœ¬è§„åˆ™</h3>
                <p data-i18n="manual.basicRulesText">å¾·å·æ‰‘å…‹ï¼ˆTexas Hold'emï¼‰æ˜¯ä¸€ç§æµè¡Œçš„æ‰‘å…‹å˜ä½“ï¼Œæ¯ä½ç©å®¶å‘2å¼ åº•ç‰Œï¼Œé€šè¿‡ä¸5å¼ å…¬å…±ç‰Œç»“åˆç»„æˆæœ€ä½³çš„5å¼ ç‰Œå‹ã€‚</p>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.gameFlow">æ¸¸æˆæµç¨‹</h3>
                <ul>
                    <li><strong data-i18n="manual.preflop">ç¿»å‰ï¼ˆPre-flopï¼‰</strong>ï¼š<span data-i18n="manual.preflopDesc">æ¯ä½ç©å®¶è·å¾—2å¼ åº•ç‰Œï¼Œæ ¹æ®ç‰ŒåŠ›å†³å®šè·Ÿæ³¨ã€åŠ æ³¨æˆ–å¼ƒç‰Œ</span></li>
                    <li><strong data-i18n="manual.flop">ç¿»ç‰Œï¼ˆFlopï¼‰</strong>ï¼š<span data-i18n="manual.flopDesc">å‘å‡ºå‰3å¼ å…¬å…±ç‰Œï¼Œè¿›è¡Œæ–°ä¸€è½®ä¸‹æ³¨</span></li>
                    <li><strong data-i18n="manual.turn">è½¬ç‰Œï¼ˆTurnï¼‰</strong>ï¼š<span data-i18n="manual.turnDesc">å‘å‡ºç¬¬4å¼ å…¬å…±ç‰Œï¼Œç»§ç»­ä¸‹æ³¨</span></li>
                    <li><strong data-i18n="manual.river">æ²³ç‰Œï¼ˆRiverï¼‰</strong>ï¼š<span data-i18n="manual.riverDesc">å‘å‡ºç¬¬5å¼ å…¬å…±ç‰Œï¼Œæœ€åä¸€è½®ä¸‹æ³¨</span></li>
                    <li><strong data-i18n="manual.showdown">æ‘Šç‰Œï¼ˆShowdownï¼‰</strong>ï¼š<span data-i18n="manual.showdownDesc">æ¯”è¾ƒç‰Œå‹å¤§å°ï¼Œæœ€å¤§ç‰Œå‹è·èƒœ</span></li>
                </ul>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.handRankings">ç‰Œå‹æ’åï¼ˆä»å¤§åˆ°å°ï¼‰</h3>
                <div class="hand-rankings">
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.royalFlush">çš‡å®¶åŒèŠ±é¡º</span>
                        <span class="hand-rank-example">Aâ™  Kâ™  Qâ™  Jâ™  10â™ </span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.straightFlush">åŒèŠ±é¡º</span>
                        <span class="hand-rank-example">9â™¥ 8â™¥ 7â™¥ 6â™¥ 5â™¥</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.fourOfKind">å››æ¡</span>
                        <span class="hand-rank-example">Kâ™£ Kâ™¦ Kâ™¥ Kâ™  3â™¦</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.fullHouse">è‘«èŠ¦</span>
                        <span class="hand-rank-example">Qâ™  Qâ™¥ Qâ™¦ 7â™£ 7â™ </span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.flush">åŒèŠ±</span>
                        <span class="hand-rank-example">Aâ™¦ Jâ™¦ 9â™¦ 6â™¦ 2â™¦</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.straight">é¡ºå­</span>
                        <span class="hand-rank-example">10â™  9â™¥ 8â™¦ 7â™£ 6â™ </span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.threeOfKind">ä¸‰æ¡</span>
                        <span class="hand-rank-example">8â™£ 8â™¦ 8â™¥ Kâ™  4â™¦</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.twoPair">ä¸¤å¯¹</span>
                        <span class="hand-rank-example">Aâ™  Aâ™¥ 5â™£ 5â™¦ 9â™ </span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.onePair">ä¸€å¯¹</span>
                        <span class="hand-rank-example">Jâ™¦ Jâ™  10â™¥ 8â™£ 3â™¦</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.highCard">é«˜ç‰Œ</span>
                        <span class="hand-rank-example">Aâ™  Kâ™¦ Qâ™¥ 8â™£ 5â™ </span>
                    </div>
                </div>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.keyConcepts">å…³é”®æ¦‚å¿µ</h3>
                <ul>
                    <li><strong data-i18n="manual.potOdds">åº•æ± èµ”ç‡ï¼ˆPot Oddsï¼‰</strong>ï¼š<span data-i18n="manual.potOddsDesc">å½“å‰è·Ÿæ³¨æ‰€éœ€ç­¹ç ä¸åº•æ± å¤§å°çš„æ¯”ä¾‹</span></li>
                    <li><strong data-i18n="manual.impliedOdds">éšå«èµ”ç‡ï¼ˆImplied Oddsï¼‰</strong>ï¼š<span data-i18n="manual.impliedOddsDesc">è€ƒè™‘åç»­å¯èƒ½èµ¢å¾—ç­¹ç çš„èµ”ç‡</span></li>
                    <li><strong data-i18n="manual.position">ä½ç½®ï¼ˆPositionï¼‰</strong>ï¼š<span data-i18n="manual.positionDesc">ç›¸å¯¹äºåº„å®¶ä½ç½®ï¼Œåä½ç½®æœ‰ä¿¡æ¯ä¼˜åŠ¿</span></li>
                    <li><strong data-i18n="manual.spr">ç­¹ç -åº•æ± æ¯”ï¼ˆSPRï¼‰</strong>ï¼š<span data-i18n="manual.sprDesc">æœ‰æ•ˆç­¹ç é™¤ä»¥åº•æ± å¤§å°</span></li>
                    <li><strong data-i18n="manual.draws">å¬ç‰Œï¼ˆDrawï¼‰</strong>ï¼š<span data-i18n="manual.drawsDesc">éœ€è¦ç‰¹å®šç‰Œæ‰èƒ½æˆç‰Œçš„ç‰Œå‹</span></li>
                </ul>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.positions">ä½ç½®è¯¦è§£</h3>
                <p data-i18n="manual.positionsIntro">åœ¨å¾·å·æ‰‘å…‹ä¸­ï¼Œä½ ç›¸å¯¹äºåº„å®¶æŒ‰é’®çš„ä½ç½®å†³å®šäº†è¡ŒåŠ¨é¡ºåºï¼Œæ˜¯å½±å“ç­–ç•¥çš„å…³é”®å› ç´ ï¼š</p>

                <div class="position-categories">
                    <div class="position-category">
                        <h4 data-i18n="manual.earlyPositions">å‰ä½ï¼ˆEarly Positionï¼‰- æœ€å…ˆè¡ŒåŠ¨</h4>
                        <ul>
                            <li><strong data-i18n="manual.utg">UTGï¼ˆæªå£ä½ï¼‰</strong>ï¼š<span data-i18n="manual.utgDesc">ç¿»å‰ç¬¬ä¸€ä¸ªè¡ŒåŠ¨ï¼Œä¿¡æ¯æœ€å°‘ï¼Œéœ€è¦æœ€å¼ºçš„ç‰Œ</span></li>
                            <li><strong data-i18n="manual.utg1">UTG+1</strong>ï¼š<span data-i18n="manual.utg1Desc">ç¬¬äºŒä¸ªè¡ŒåŠ¨ä½ç½®ï¼Œä»ç„¶éœ€è¦è¾ƒå¼ºæ‰‹ç‰Œ</span></li>
                            <li><strong data-i18n="manual.utg2">UTG+2</strong>ï¼š<span data-i18n="manual.utg2Desc">å¯ä»¥ç•¥å¾®æ”¾å®½æ‰‹ç‰Œè¦æ±‚</span></li>
                        </ul>
                    </div>

                    <div class="position-category">
                        <h4 data-i18n="manual.middlePositions">ä¸­ä½ï¼ˆMiddle Positionï¼‰</h4>
                        <ul>
                            <li><strong data-i18n="manual.mp1">MP1ï¼ˆä¸­é—´ä½1ï¼‰</strong>ï¼š<span data-i18n="manual.mp1Desc">å¯ä»¥ç©æ›´å¤šè¾¹é™…æ‰‹ç‰Œ</span></li>
                            <li><strong data-i18n="manual.mp2">MP2ï¼ˆä¸­é—´ä½2ï¼‰</strong>ï¼š<span data-i18n="manual.mp2Desc">ä½ç½®å¼€å§‹å˜å¾—æœ‰åˆ©</span></li>
                            <li><strong data-i18n="manual.mp3">MP3ï¼ˆä¸­é—´ä½3ï¼‰</strong>ï¼š<span data-i18n="manual.mp3Desc">æ¥è¿‘æ™šä½çš„ä¼˜åŠ¿</span></li>
                        </ul>
                    </div>

                    <div class="position-category">
                        <h4 data-i18n="manual.latePositions">åä½ï¼ˆLate Positionï¼‰- ä¿¡æ¯ä¼˜åŠ¿</h4>
                        <ul>
                            <li><strong data-i18n="manual.lj">LJï¼ˆåŠ«åŒªä½ï¼‰</strong>ï¼š<span data-i18n="manual.ljDesc">å¯ä»¥è§‚å¯Ÿå‰é¢ç©å®¶è¡ŒåŠ¨åå†³ç­–</span></li>
                            <li><strong data-i18n="manual.hj">HJï¼ˆåŠ«æŒä½ï¼‰</strong>ï¼š<span data-i18n="manual.hjDesc">éå¸¸æœ‰åˆ©çš„ä½ç½®ï¼Œå¯ä»¥å·ç›²</span></li>
                            <li><strong data-i18n="manual.co">COï¼ˆæˆªæ–­ä½ï¼‰</strong>ï¼š<span data-i18n="manual.coDesc">ä»…æ¬¡äºæŒ‰é’®ä½çš„ä¼˜åŠ¿ä½ç½®</span></li>
                            <li><strong data-i18n="manual.btn">BTNï¼ˆæŒ‰é’®ä½ï¼‰</strong>ï¼š<span data-i18n="manual.btnDesc">ç¿»åæ°¸è¿œæœ€åè¡ŒåŠ¨ï¼Œæœ€ä½³ä½ç½®</span></li>
                        </ul>
                    </div>

                    <div class="position-category">
                        <h4 data-i18n="manual.blindPositions">ç›²æ³¨ä½ï¼ˆBlind Positionsï¼‰</h4>
                        <ul>
                            <li><strong data-i18n="manual.sb">SBï¼ˆå°ç›²ä½ï¼‰</strong>ï¼š<span data-i18n="manual.sbDesc">ç¿»åç¬¬ä¸€ä¸ªè¡ŒåŠ¨ï¼Œä½ç½®æœ€å·®ä½†å·²æŠ•å…¥ä¸€åŠå¤§ç›²</span></li>
                            <li><strong data-i18n="manual.bb">BBï¼ˆå¤§ç›²ä½ï¼‰</strong>ï¼š<span data-i18n="manual.bbDesc">ç¿»å‰æœ€åè¡ŒåŠ¨ï¼Œç¿»åç¬¬äºŒä¸ªè¡ŒåŠ¨</span></li>
                        </ul>
                    </div>
                </div>

                <div class="position-tips">
                    <h4 data-i18n="manual.positionStrategy">ä½ç½®ç­–ç•¥è¦ç‚¹</h4>
                    <ul>
                        <li data-i18n="manual.tip1">å‰ä½éœ€è¦æ›´å¼ºçš„èµ·æ‰‹ç‰Œï¼Œå› ä¸ºåé¢è¿˜æœ‰å¾ˆå¤šç©å®¶è¦è¡ŒåŠ¨</li>
                        <li data-i18n="manual.tip2">åä½å¯ä»¥ç©æ›´å¤šæŠ•æœºæ€§æ‰‹ç‰Œï¼Œè§‚å¯Ÿå¯¹æ‰‹è¡ŒåŠ¨åå†å†³ç­–</li>
                        <li data-i18n="manual.tip3">æŒ‰é’®ä½æ˜¯æœ€æœ‰åˆ©ä½ç½®ï¼Œå¯ä»¥ç”¨æ›´å®½çš„èŒƒå›´åŠ æ³¨å’Œå·ç›²</li>
                        <li data-i18n="manual.tip4">ç›²æ³¨ä½ç½®ç¿»åä¸åˆ©ï¼Œä½†ç¿»å‰å·²æœ‰æŠ•å…¥è¦è€ƒè™‘åº•æ± èµ”ç‡</li>
                    </ul>
                </div>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.strategies">å¸¸ç”¨ç­–ç•¥æ¦‚å¿µ</h3>
                <ul>
                    <li><strong data-i18n="manual.tag">ç´§å‡¶ï¼ˆTAGï¼‰</strong>ï¼š<span data-i18n="manual.tagDesc">åªç©å¼ºç‰Œä½†ç©å¾—æ¿€è¿›</span></li>
                    <li><strong data-i18n="manual.lag">æ¾å‡¶ï¼ˆLAGï¼‰</strong>ï¼š<span data-i18n="manual.lagDesc">ç©è¾ƒå¤šç‰Œå‹ä¸”æ¿€è¿›ä¸‹æ³¨</span></li>
                    <li><strong data-i18n="manual.valueBet">ä»·å€¼ä¸‹æ³¨</strong>ï¼š<span data-i18n="manual.valueBetDesc">æœ‰å¼ºç‰Œæ—¶ä¸‹æ³¨è·å–ä»·å€¼</span></li>
                    <li><strong data-i18n="manual.bluff">è¯ˆå”¬ï¼ˆBluffï¼‰</strong>ï¼š<span data-i18n="manual.bluffDesc">ç”¨å¼±ç‰Œä¸‹æ³¨è¿«ä½¿å¯¹æ‰‹å¼ƒç‰Œ</span></li>
                    <li><strong data-i18n="manual.semiBluff">åŠè¯ˆå”¬</strong>ï¼š<span data-i18n="manual.semiBluffDesc">ç”¨å¬ç‰Œä¸‹æ³¨ï¼Œæ—¢å¯èƒ½æˆç‰Œä¹Ÿå¯èƒ½è®©å¯¹æ‰‹å¼ƒç‰Œ</span></li>
                </ul>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.startingHands">æ–°æ‰‹èµ·æ‰‹ç‰Œå»ºè®®</h3>
                <p data-i18n="manual.startingHandsIntro">ä½œä¸ºæ–°æ‰‹ï¼Œå»ºè®®åªç©ä»¥ä¸‹å¼ºç‰Œï¼Œé¿å…å¤æ‚å†³ç­–ï¼š</p>

                <div class="hand-categories">
                    <div class="hand-category premium">
                        <h4 data-i18n="manual.premiumHands">é¡¶çº§å¼ºç‰Œï¼ˆä»»ä½•ä½ç½®éƒ½å¯ä»¥ç©ï¼‰</h4>
                        <div class="hand-examples">
                            <span class="hand-example">AA</span>
                            <span class="hand-example">KK</span>
                            <span class="hand-example">QQ</span>
                            <span class="hand-example">AKs</span>
                            <span class="hand-example">AKo</span>
                        </div>
                    </div>

                    <div class="hand-category strong">
                        <h4 data-i18n="manual.strongHands">å¼ºç‰Œï¼ˆä¸­åä½å¯ä»¥ç©ï¼‰</h4>
                        <div class="hand-examples">
                            <span class="hand-example">JJ</span>
                            <span class="hand-example">TT</span>
                            <span class="hand-example">99</span>
                            <span class="hand-example">AQs</span>
                            <span class="hand-example">AQo</span>
                            <span class="hand-example">AJs</span>
                            <span class="hand-example">KQs</span>
                        </div>
                    </div>

                    <div class="hand-category speculative">
                        <h4 data-i18n="manual.speculativeHands">æŠ•æœºç‰Œï¼ˆä»…åä½è€ƒè™‘ï¼‰</h4>
                        <div class="hand-examples">
                            <span class="hand-example">88-22</span>
                            <span class="hand-example">ATs</span>
                            <span class="hand-example">A9s-A2s</span>
                            <span class="hand-example">KJs</span>
                            <span class="hand-example">QJs</span>
                            <span class="hand-example">JTs</span>
                        </div>
                    </div>
                </div>

                <div class="hand-tips">
                    <p data-i18n="manual.handTips">ğŸ’¡ "s"è¡¨ç¤ºåŒèŠ±è‰²ï¼Œ"o"è¡¨ç¤ºä¸åŒèŠ±è‰²ã€‚æ–°æ‰‹å»ºè®®ï¼šå‰ä½åªç©é¡¶çº§å¼ºç‰Œï¼Œåä½å¯ä»¥é€‚å½“æ”¾å®½ã€‚</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_STORAGE_KEY = 'qpds.apiBaseUrl';
        const API_QUERY_PARAM = 'api';
        const LOCAL_API_URL = 'http://localhost:8080';
        const GITHUB_DEFAULT_API_URL = 'https://qpds-backend.onrender.com';

        function sanitizeApiUrl(url) {
            if (!url) {
                return null;
            }
            try {
                const parsed = new URL(url);
                if (!['http:', 'https:'].includes(parsed.protocol)) {
                    return null;
                }
                return parsed.origin;
            } catch (error) {
                return null;
            }
        }

        function resolveDefaultApiUrl() {
            if (window.location.hostname.endsWith('github.io')) {
                return GITHUB_DEFAULT_API_URL;
            }
            const override = sanitizeApiUrl(window.API_BASE_URL);
            if (override) {
                return override;
            }
            return LOCAL_API_URL;
        }

        function resolveApiUrl({ skipQuery = false } = {}) {
            if (!skipQuery) {
                const params = new URLSearchParams(window.location.search);
                const fromQuery = sanitizeApiUrl(params.get(API_QUERY_PARAM));
                if (fromQuery) {
                    params.delete(API_QUERY_PARAM);
                    const nextQuery = params.toString();
                    const nextUrl = `${window.location.pathname}${nextQuery ? `?${nextQuery}` : ''}${window.location.hash}`;
                    window.history.replaceState({}, '', nextUrl);
                    localStorage.setItem(API_STORAGE_KEY, fromQuery);
                    return fromQuery;
                }
            }

            const stored = sanitizeApiUrl(localStorage.getItem(API_STORAGE_KEY));
            if (stored) {
                return stored;
            }

            return resolveDefaultApiUrl();
        }

        let API_URL = resolveApiUrl();

        let deckGrid;
        let heroSlots;
        let boardSlots;
        let streetOptions;
        let positionSelect;
        let riskSlider;
        let riskValue;
        let langToggle;
        let apiConfigBtn;
        let apiStatusLabel;
        let loadingIndicator;
        let actionValue;
        let confidenceValue;
        let evValue;
        let resultBanner;
        let explanationBox;
        let factorsGrid;
        let errorBox;
        let summaryGrid;
        let opponentInsightsPanel;
        let opponentArchetype;
        let opponentSummary;
        let opponentNotesContainer;
        let opponentAggressionMetric;
        let opponentBettingMetric;
        let opponentPsychologyMetric;
        let opponentRangeMetric;
        let opAggressionInput;
        let opTightnessInput;
        let opBluffInput;
        let opConfidenceInput;
        let opTiltInput;
        let opBetPctInput;
        let opActionStreet;
        let opActionType;
        let opActionAmount;
        let opActionPot;
        let opNotesInput;
        let opAggressionValue;
        let opTightnessValue;
        let opBluffValue;
        let opConfidenceValue;
        let opTiltValue;

        const translations = {
            en: {
                title: 'QPDS',
                subtitle: 'Quantitative Poker Decision System',
                beginner: {
                    title: 'ğŸš€ Quick Start Guide',
                    intro: 'First time using? Follow these steps:',
                    step1: 'Select hole cards: Click empty slots under "Your Hole Cards", then choose two cards from deck below',
                    step2: 'Set stage: Choose current game stage (beginners should start with "Preflop")',
                    step3: 'Input parameters: Set pot 100, to call 20, both stacks 500',
                    step4: 'Choose position: If unsure, select "Button (BTN)"',
                    step5: 'Get recommendation: Click "Get Recommendation" to see suggested action',
                    dismiss: 'Got it!'
                },
                lesson: {
                    heading: 'No-Limit Texas Hold\'em Essentials',
                    goal: {
                        title: 'The Goal',
                        copy: 'Win chips either by showing the strongest five-card hand at showdown or by making everyone else fold.'
                    },
                    structure: {
                        title: 'Hand Structure',
                        copy: 'Two private cards per player, blinds create the pot, and up to four betting rounds across flop, turn, and river community cards.'
                    },
                    position: {
                        title: 'Position & Information',
                        copy: 'Button acts last post-flop and has the most information; blinds must act first on later streets.'
                    },
                    strategy: {
                        title: 'Quant Thinking',
                        copy: 'Equity, pot odds, and your risk slider drive disciplined, data-backed decisions.'
                    },
                    cheatsheet: {
                        title: 'Quick Ringside Cheatsheet',
                        preflop: 'Preflop Riff',
                        preflop1: 'Button: open 3x with wider range, steal blinds aggressively.',
                        preflop2: 'Early position: premium pairs + strong suited connectors only.',
                        preflop3: 'Big blind defense: call only if pot odds â‰¥ 3:1.',
                        flop: 'Flop Reading',
                        flop1: 'Dry boards: continue betting with middle pairs to deny equity.',
                        flop2: 'Wet boards: protect your made hands, size down to control pot.',
                        flop3: 'Strong draws: count outs Ã—4 to estimate hit probability.',
                        turn: 'Turn Decisions',
                        turn1: 'SPR < 1.5: strong hands can commit stacks.',
                        turn2: 'Facing raises: reassess range advantage before stacking off.',
                        turn3: 'Semi-bluff only if fold equity Ã— pot â‰¥ risked chips.',
                        river: 'River Execution',
                        river1: 'Value bets: only if worse hands can call you.',
                        river2: 'Bluffs: tell a coherent story and block villainâ€™s top combos.',
                        river3: 'Missed draws: balance fold equity vs showdown value.'
                    }
                },
                state: {
                    heading: 'Game State',
                    hero: 'Your Hole Cards',
                    board: 'Community Cards',
                    parameters: 'Stacks & Inputs'
                },
                streets: {
                    PREFLOP: 'Preflop',
                    FLOP: 'Flop',
                    TURN: 'Turn',
                    RIVER: 'River'
                },
                fields: {
                    pot: 'Pot Size',
                    toCall: 'Bet to Call',
                    heroStack: 'Your Stack',
                    villainStack: 'Villain Stack',
                    position: 'Your Position',
                    villainRange: 'Villain Range'
                },
                summary: {
                    heading: 'Current Inputs',
                    items: {
                        pot: 'Pot Size',
                        toCall: 'Bet to Call',
                        heroStack: 'Your Stack',
                        villainStack: 'Villain Stack',
                        street: 'Street',
                        position: 'Position',
                        risk: 'Risk Preference',
                        opponentModel: 'Opponent Read'
                    }
                },
                placeholders: {
                    pot: 'e.g. 100',
                    toCall: 'e.g. 20',
                    heroStack: 'e.g. 500',
                    villainStack: 'e.g. 500',
                    villainRange: 'AA,KK,QQ,AKs'
                },
                risk: {
                    conservative: 'Conservative',
                    aggressive: 'Aggressive'
                },
                buttons: {
                    recommend: 'Get Recommendation',
                    equity: 'Equity Only',
                    reset: 'Reset Cards',
                    gameManual: 'ğŸƒ Game Manual',
                    apiConfig: 'âš™ï¸ API'
                },
                opponent: {
                    heading: 'Opponent Model',
                    aggression: {
                        label: 'Aggression',
                        low: 'Passive',
                        high: 'Hyper aggressive'
                    },
                    tightness: {
                        label: 'Opening Range',
                        wide: 'Loose',
                        narrow: 'Tight'
                    },
                    bluff: {
                        label: 'Bluff Frequency',
                        low: 'Rare',
                        high: 'Frequent'
                    },
                    confidence: {
                        label: 'Table Confidence',
                        low: 'Hesitant',
                        high: 'Confident'
                    },
                    tilt: {
                        label: 'Emotional Tilt',
                        calm: 'Composed',
                        hot: 'Near tilt'
                    },
                    bet: {
                        label: 'Latest bet % of pot',
                        placeholder: 'e.g. 70'
                    },
                    action: {
                        label: 'Latest action',
                        bet: 'Bet',
                        raise: 'Raise',
                        call: 'Call',
                        check: 'Check',
                        amount: 'Action amount',
                        pot: 'Pot before action'
                    },
                    notes: {
                        label: 'Notes',
                        placeholder: 'e.g. C-bets flop, tight river calls'
                    },
                    insights: {
                        heading: 'Opponent Insights',
                        aggression: 'Aggression Index',
                        betting: 'Betting Pressure',
                        psychology: 'Psychological Pressure',
                        range: 'Range Advantage'
                    }
                },
                status: {
                    apiLabel: 'API',
                    checking: 'checkingâ€¦',
                    connected: 'online',
                    failed: 'unreachable'
                },
                prompts: {
                    apiBase: 'Enter backend API base URL (https://your-service.onrender.com)',
                    apiBaseInvalid: 'Please enter a valid http(s) URL.',
                    apiBaseCleared: 'API base reset to default.'
                },
                deck: {
                    heading: 'Deck (click to pick cards)',
                    hint: 'Click an empty slot then choose a card. Used cards grey out; use the âœ• tag to clear a slot.'
                },
                loading: 'Crunching the hand for you...',
                result: {
                    action: 'Recommended Action',
                    confidence: 'Confidence',
                    ev: 'Expected Value'
                },
                factors: {
                    heading: 'Key Factors',
                    names: {
                        equity: 'Equity',
                        pot_odds: 'Pot Odds',
                        hand_strength: 'Hand Strength',
                        position_factor: 'Position',
                        stack_to_pot_ratio: 'SPR',
                        opponent_aggression: 'Opponent Aggression',
                        opponent_tightness: 'Opponent Tightness',
                        betting_pressure: 'Betting Pressure',
                        board_pressure: 'Board Pressure',
                        range_advantage: 'Range Advantage',
                        psychological_pressure: 'Psychological Pressure',
                        bluff_tendency: 'Bluff Tendency',
                        fold_equity: 'Fold Equity',
                        outs: 'Outs',
                        board_wetness: 'Board Texture',
                        effective_stack: 'Effective Stack',
                        draw_probability: 'Draw Probability',
                        implied_odds: 'Implied Odds',
                        pot_commitment: 'Pot Commitment'
                    }
                },
                errors: {
                    missingCards: 'Please select two unique hole cards before running an analysis.',
                    boardRequirement: 'Please provide the correct number of community cards for the selected street.'
                },
                manual: {
                    title: 'Texas Hold\'em Game Manual',
                    basicRules: 'Basic Rules',
                    basicRulesText: 'Texas Hold\'em is a popular poker variant where each player receives 2 hole cards and combines them with 5 community cards to form the best possible 5-card hand.',
                    gameFlow: 'Game Flow',
                    preflop: 'Pre-flop',
                    preflopDesc: 'Each player receives 2 hole cards, decide to call, raise or fold based on hand strength',
                    flop: 'Flop',
                    flopDesc: 'First 3 community cards are dealt, new betting round begins',
                    turn: 'Turn',
                    turnDesc: '4th community card is dealt, continue betting',
                    river: 'River',
                    riverDesc: '5th community card is dealt, final betting round',
                    showdown: 'Showdown',
                    showdownDesc: 'Compare hand rankings, highest hand wins',
                    handRankings: 'Hand Rankings (High to Low)',
                    royalFlush: 'Royal Flush',
                    straightFlush: 'Straight Flush',
                    fourOfKind: 'Four of a Kind',
                    fullHouse: 'Full House',
                    flush: 'Flush',
                    straight: 'Straight',
                    threeOfKind: 'Three of a Kind',
                    twoPair: 'Two Pair',
                    onePair: 'One Pair',
                    highCard: 'High Card',
                    keyConcepts: 'Key Concepts',
                    potOdds: 'Pot Odds',
                    potOddsDesc: 'Ratio of current bet to pot size',
                    impliedOdds: 'Implied Odds',
                    impliedOddsDesc: 'Considering potential future winnings',
                    position: 'Position',
                    positionDesc: 'Relative to dealer button, later position has information advantage',
                    spr: 'Stack-to-Pot Ratio (SPR)',
                    sprDesc: 'Effective stack divided by pot size',
                    draws: 'Draws',
                    drawsDesc: 'Hands that need specific cards to improve',
                    positions: 'Position Guide',
                    positionsIntro: 'In Texas Hold\'em, your position relative to the dealer button determines action order and is crucial for strategy:',
                    earlyPositions: 'Early Position - Act First',
                    utg: 'UTG (Under the Gun)',
                    utgDesc: 'First to act preflop, least information, need strongest hands',
                    utg1: 'UTG+1',
                    utg1Desc: 'Second position to act, still need strong hands',
                    utg2: 'UTG+2',
                    utg2Desc: 'Can slightly widen hand requirements',
                    middlePositions: 'Middle Position',
                    mp1: 'MP1 (Middle Position 1)',
                    mp1Desc: 'Can play more marginal hands',
                    mp2: 'MP2 (Middle Position 2)',
                    mp2Desc: 'Position starts becoming favorable',
                    mp3: 'MP3 (Middle Position 3)',
                    mp3Desc: 'Approaching late position advantages',
                    latePositions: 'Late Position - Information Advantage',
                    lj: 'LJ (Lojack)',
                    ljDesc: 'Can observe early position actions before deciding',
                    hj: 'HJ (Hijack)',
                    hjDesc: 'Very favorable position, can steal blinds',
                    co: 'CO (Cutoff)',
                    coDesc: 'Second best position after button',
                    btn: 'BTN (Button)',
                    btnDesc: 'Always acts last post-flop, best position',
                    blindPositions: 'Blind Positions',
                    sb: 'SB (Small Blind)',
                    sbDesc: 'Acts first post-flop, worst position but half big blind invested',
                    bb: 'BB (Big Blind)',
                    bbDesc: 'Acts last preflop, second post-flop',
                    positionStrategy: 'Position Strategy Tips',
                    tip1: 'Early position needs stronger starting hands as many players act after you',
                    tip2: 'Late position can play more speculative hands, observe opponents first',
                    tip3: 'Button is most profitable position, can raise and steal with wider range',
                    tip4: 'Blind positions are disadvantaged post-flop but consider pot odds with investment',
                    strategies: 'Common Strategy Concepts',
                    tag: 'Tight-Aggressive (TAG)',
                    tagDesc: 'Play strong hands aggressively',
                    lag: 'Loose-Aggressive (LAG)',
                    lagDesc: 'Play more hands aggressively',
                    valueBet: 'Value Bet',
                    valueBetDesc: 'Bet strong hands for value',
                    bluff: 'Bluff',
                    bluffDesc: 'Bet weak hands to make opponents fold',
                    semiBluff: 'Semi-bluff',
                    semiBluffDesc: 'Bet drawing hands that can improve or make opponents fold',
                    startingHands: 'Starting Hands Guide',
                    startingHandsIntro: 'As a beginner, stick to these strong hands to avoid complex decisions:',
                    premiumHands: 'Premium Hands (Play from any position)',
                    strongHands: 'Strong Hands (Play from middle/late position)',
                    speculativeHands: 'Speculative Hands (Late position only)',
                    handTips: 'ğŸ’¡ "s" means suited, "o" means offsuit. Beginner tip: Early position = premium hands only, late position = more flexibility.'
                }
            },
            zh: {
                title: 'QPDS',
                subtitle: 'é‡åŒ–å¾·å·æ‰‘å…‹å†³ç­–è¾…åŠ©ç³»ç»Ÿ',
                beginner: {
                    title: 'ğŸš€ æ–°æ‰‹å¿«é€Ÿå…¥é—¨',
                    intro: 'ç¬¬ä¸€æ¬¡ä½¿ç”¨ï¼ŸæŒ‰ä»¥ä¸‹æ­¥éª¤å¼€å§‹ï¼š',
                    step1: 'é€‰æ‹©åº•ç‰Œï¼šç‚¹å‡»å·¦è¾¹"ä½ çš„åº•ç‰Œ"åŒºåŸŸçš„ç©ºæ§½ï¼Œç„¶åä»ä¸‹æ–¹ç‰Œå †é€‰æ‹©ä¸¤å¼ ç‰Œ',
                    step2: 'è®¾ç½®é˜¶æ®µï¼šé€‰æ‹©å½“å‰æ¸¸æˆé˜¶æ®µï¼ˆå»ºè®®æ–°æ‰‹ä»"ç¿»å‰"å¼€å§‹ï¼‰',
                    step3: 'è¾“å…¥å‚æ•°ï¼šè®¾ç½®åº•æ± 100ã€è·Ÿæ³¨20ã€åŒæ–¹ç­¹ç å„500',
                    step4: 'é€‰æ‹©ä½ç½®ï¼šå¦‚ä¸ç¡®å®šé€‰æ‹©"æŒ‰é’®ä½(BTN)"',
                    step5: 'è·å–å»ºè®®ï¼šç‚¹å‡»"è·å–å†³ç­–å»ºè®®"æŸ¥çœ‹æ¨èè¡ŒåŠ¨',
                    dismiss: 'æˆ‘çŸ¥é“äº†'
                },
                lesson: {
                    heading: 'æ— é™æ³¨å¾·å·æ‰‘å…‹ï¼šè§„åˆ™é€Ÿè§ˆ',
                    goal: {
                        title: 'æ ¸å¿ƒç›®æ ‡',
                        copy: 'é€šè¿‡æ‘Šç‰Œæ‹¿ä¸‹æœ€å¤§ç‰ŒåŠ›ï¼Œæˆ–è¿«ä½¿æ‰€æœ‰å¯¹æ‰‹å¼ƒç‰Œï¼Œèµ¢å–åº•æ± ç­¹ç ã€‚'
                    },
                    structure: {
                        title: 'å®Œæ•´æµç¨‹',
                        copy: 'æ¯ä½ç©å®¶èµ·æ‰‹ä¸¤å¼ åº•ç‰Œï¼Œç›²æ³¨æ³¨å…¥åº•æ± ï¼Œå…¬å…±ç‰Œä¾æ¬¡ç¿»ç‰Œåœˆã€è½¬ç‰Œåœˆã€æ²³ç‰Œåœˆäº®å‡ºï¼Œæœ€å¤šå››è½®ä¸‹æ³¨ã€‚'
                    },
                    position: {
                        title: 'ä½ç½®ä¸ä¿¡æ¯',
                        copy: 'æŒ‰é’®ä½ç¿»ç‰Œåæœ€åè¡ŒåŠ¨ï¼Œä¿¡æ¯ä¼˜åŠ¿æœ€å¤§ï¼›ç›²æ³¨ä½ç½®ç¿»ç‰Œåéœ€è¦ä¼˜å…ˆè¡ŒåŠ¨ã€‚'
                    },
                    strategy: {
                        title: 'é‡åŒ–æ€ç»´',
                        copy: 'èƒœç‡ã€åº•æ± èµ”ç‡ã€é£é™©åå¥½å…±åŒé©±åŠ¨ç†æ€§å†³ç­–ï¼Œä¿æŒçºªå¾‹é¿å…æƒ…ç»ªæ³¢åŠ¨ã€‚'
                    },
                    cheatsheet: {
                        title: 'ç‰Œæ¡Œé€ŸæŸ¥å®å…¸',
                        preflop: 'ç¿»å‰å£ä»¤',
                        preflop1: 'æŒ‰é’®ä½å¼€å±€ 3 å€ç›²æ³¨ï¼Œç”¨å®½èŒƒå›´å·ç›²',
                        preflop2: 'å‰ä½ç´§å‡¶ï¼šä»…é¡¶çº§å¯¹å­ + å¼ºåŒèŠ±è¿ç‰Œ',
                        preflop3: 'å¤§ç›²é˜²å®ˆï¼šåªæœ‰ç‰Œä»· â‰¥ 3:1 æ‰è€ƒè™‘è·Ÿæ³¨',
                        flop: 'ç¿»ç‰Œè¯»ç‰Œ',
                        flop1: 'å¹²ç‡¥ç‰Œé¢ï¼šä¸­ç­‰å¯¹å­å¯æŒç»­ä¸‹æ³¨å‹æ¦¨è¶…å¯¹',
                        flop2: 'æ¹¿æ¶¦ç‰Œé¢ï¼šä¼˜å…ˆä¿æŠ¤æˆæ‰‹ï¼Œé€‚åº¦ç¼©å°ä¸‹æ³¨å°ºåº¦',
                        flop3: 'ä¸­é¡º/åŒèŠ±å¬ç‰Œï¼šè¡¥ç‰Œæ•° Ã—4 â‰ˆ ç¿»ç‰Œåå‘½ä¸­ç‡',
                        turn: 'è½¬ç‰Œå†³ç­–',
                        turn1: 'SPR < 1.5ï¼šå¼ºç‰Œå¯ç›´æ¥æ¨æ»¡æŠ•å…¥',
                        turn2: 'é­é‡åŠ æ³¨ï¼šåˆ¤æ–­èŒƒå›´ä¼˜åŠ¿æ˜¯å¦åè½¬',
                        turn3: 'åŠè¯ˆå”¬ï¼šç¡®ä¿å¼ƒç‰Œç‡ Ã— åº•æ±  â‰¥ æœ¬è½®æˆæœ¬',
                        river: 'æ²³ç‰Œæ‰§è¡Œ',
                        river1: 'ä»·å€¼ä¸‹æ³¨ï¼šç¡®ä¿æ›´å¼±çš„ç‰Œæ„¿æ„è·Ÿæ³¨',
                        river2: 'ç²¾å‡†è¯ˆå”¬ï¼šè®²å‡ºå¼ºç‰Œæ•…äº‹å¹¶é˜»æ–­å¯¹æ‰‹é¡¶ç‰Œ',
                        river3: 'é”™è¿‡å¬ç‰Œï¼šè¡¡é‡å¼ƒç‰Œç‡å’Œæ‘Šç‰Œä»·å€¼å†å†³å®š'
                    }
                },
                state: {
                    heading: 'ç‰Œå±€è®¾ç½®',
                    hero: 'ä½ çš„åº•ç‰Œ',
                    board: 'å…¬å…±ç‰Œ',
                    parameters: 'ç­¹ç ä¸å‚æ•°'
                },
                streets: {
                    PREFLOP: 'ç¿»å‰ (Preflop)',
                    FLOP: 'ç¿»ç‰Œåœˆ (Flop)',
                    TURN: 'è½¬ç‰Œåœˆ (Turn)',
                    RIVER: 'æ²³ç‰Œåœˆ (River)'
                },
                fields: {
                    pot: 'åº•æ± å¤§å°',
                    toCall: 'éœ€è¦è·Ÿæ³¨',
                    heroStack: 'ä½ çš„ç­¹ç ',
                    villainStack: 'å¯¹æ‰‹ç­¹ç ',
                    position: 'ä½ çš„ä½ç½®',
                    villainRange: 'å¯¹æ‰‹èŒƒå›´'
                },
                summary: {
                    heading: 'å½“å‰è¾“å…¥æ¦‚è§ˆ',
                    items: {
                        pot: 'åº•æ± å¤§å°',
                        toCall: 'è·Ÿæ³¨é‡‘é¢',
                        heroStack: 'ä½ çš„ç­¹ç ',
                        villainStack: 'å¯¹æ‰‹ç­¹ç ',
                        street: 'å½“å‰é˜¶æ®µ',
                        position: 'ä½ çš„ä½ç½®',
                        risk: 'é£é™©åå¥½',
                        opponentModel: 'å¯¹æ‰‹ç”»åƒ'
                    }
                },
                placeholders: {
                    pot: 'ä¾‹å¦‚ 100',
                    toCall: 'ä¾‹å¦‚ 20',
                    heroStack: 'ä¾‹å¦‚ 500',
                    villainStack: 'ä¾‹å¦‚ 500',
                    villainRange: 'AA,KK,QQ,AKs'
                },
                risk: {
                    conservative: 'ä¿å®ˆ',
                    aggressive: 'æ¿€è¿›'
                },
                buttons: {
                    recommend: 'è·å–å†³ç­–å»ºè®®',
                    equity: 'ä»…è®¡ç®—èƒœç‡',
                    reset: 'é‡ç½®ç‰Œé¢',
                    gameManual: 'ğŸƒ æ¸¸æˆæ‰‹å†Œ',
                    apiConfig: 'âš™ï¸ APIé…ç½®'
                },
                opponent: {
                    heading: 'å¯¹æ‰‹å»ºæ¨¡',
                    aggression: {
                        label: 'æ¿€è¿›ç¨‹åº¦',
                        low: 'åè¢«åŠ¨',
                        high: 'è¶…æ¿€è¿›'
                    },
                    tightness: {
                        label: 'èµ·æ‰‹èŒƒå›´',
                        wide: 'å®½æ¾',
                        narrow: 'ç´§å®'
                    },
                    bluff: {
                        label: 'è¯ˆå”¬é¢‘ç‡',
                        low: 'ç½•è§',
                        high: 'é¢‘ç¹'
                    },
                    confidence: {
                        label: 'æ¡Œé¢è‡ªä¿¡',
                        low: 'çŠ¹è±«',
                        high: 'è‡ªä¿¡'
                    },
                    tilt: {
                        label: 'æƒ…ç»ªæ³¢åŠ¨',
                        calm: 'å†·é™',
                        hot: 'æ¥è¿‘å¤±æ§'
                    },
                    bet: {
                        label: 'æœ€è¿‘ä¸‹æ³¨å åº•æ± %',
                        placeholder: 'ä¾‹å¦‚ 70'
                    },
                    action: {
                        label: 'æœ€è¿‘åŠ¨ä½œ',
                        bet: 'ä¸‹æ³¨',
                        raise: 'åŠ æ³¨',
                        call: 'è·Ÿæ³¨',
                        check: 'è¿‡ç‰Œ',
                        amount: 'åŠ¨ä½œé‡‘é¢',
                        pot: 'è¡ŒåŠ¨å‰åº•æ± '
                    },
                    notes: {
                        label: 'é¢å¤–å¤‡æ³¨',
                        placeholder: 'ä¾‹å¦‚ï¼šç¿»ç‰ŒåœˆæŒç»­ä¸‹æ³¨ï¼Œæ²³ç‰Œè¶‹äºç´§å‡¶'
                    },
                    insights: {
                        heading: 'å¯¹æ‰‹ç”»åƒ',
                        aggression: 'æ¿€è¿›æŒ‡æ•°',
                        betting: 'ä¸‹æ³¨å‹åŠ›',
                        psychology: 'å¿ƒç†å‹å¼º',
                        range: 'èŒƒå›´ä¼˜åŠ¿'
                    }
                },
                status: {
                    apiLabel: 'åç«¯',
                    checking: 'æ£€æµ‹ä¸­â€¦',
                    connected: 'å·²è¿æ¥',
                    failed: 'æ— æ³•è¿æ¥'
                },
                prompts: {
                    apiBase: 'è¯·è¾“å…¥åç«¯ API åœ°å€ï¼ˆä¾‹å¦‚ https://your-service.onrender.comï¼‰',
                    apiBaseInvalid: 'è¯·è¾“å…¥åˆæ³•çš„ http(s) åœ°å€ã€‚',
                    apiBaseCleared: 'å·²æ¢å¤é»˜è®¤æ¥å£åœ°å€ã€‚'
                },
                deck: {
                    heading: 'ç‰Œå †ï¼ˆç‚¹å‡»é€‰ç‰Œï¼‰',
                    hint: 'å…ˆç‚¹å‡»ç©ºæ§½å†é€‰æ‹©å¡ç‰Œï¼›è¢«é€‰ä¸­çš„å¡ç‰Œä¼šç°æ‰ï¼Œç‚¹å‡»æ§½ä½å³ä¸Šè§’çš„âœ•å³å¯æ¸…é™¤ã€‚'
                },
                loading: 'æ­£åœ¨ä¸ºä½ é‡åŒ–ç‰Œå±€...',
                result: {
                    action: 'æ¨èè¡ŒåŠ¨',
                    confidence: 'ç½®ä¿¡åº¦',
                    ev: 'æœŸæœ›å€¼'
                },
                factors: {
                    heading: 'å…³é”®å› å­',
                    names: {
                        equity: 'èƒœç‡ (Equity)',
                        pot_odds: 'åº•æ± èµ”ç‡',
                        hand_strength: 'ç‰ŒåŠ›è¯„åˆ†',
                        position_factor: 'ä½ç½®ä¼˜åŠ¿',
                        stack_to_pot_ratio: 'SPR',
                        opponent_aggression: 'å¯¹æ‰‹æ¿€è¿›åº¦',
                        opponent_tightness: 'å¯¹æ‰‹ç´§å‡¶åº¦',
                        betting_pressure: 'ä¸‹æ³¨å‹åŠ›',
                        board_pressure: 'ç‰Œé¢å‹åŠ›',
                        range_advantage: 'èŒƒå›´ä¼˜åŠ¿',
                        psychological_pressure: 'å¿ƒç†å‹å¼º',
                        bluff_tendency: 'è¯ˆå”¬å€¾å‘',
                        fold_equity: 'å¼ƒç‰Œç‡',
                        outs: 'è¡¥ç‰Œæ•°',
                        board_wetness: 'å…¬å…±ç‰Œåè°ƒåº¦',
                        effective_stack: 'æœ‰æ•ˆç­¹ç ',
                        draw_probability: 'å¬ç‰Œå‘½ä¸­ç‡',
                        implied_odds: 'éšå«èµ”ç‡',
                        pot_commitment: 'åº•æ± æŠ•å…¥åº¦'
                    }
                },
                errors: {
                    missingCards: 'è¯·å…ˆé€‰æ‹©ä¸¤å¼ å”¯ä¸€åº•ç‰Œï¼Œå†è¿›è¡Œåˆ†æã€‚',
                    boardRequirement: 'å½“å‰é˜¶æ®µéœ€è¦åŒ¹é…æ•°é‡çš„å…¬å…±ç‰Œï¼Œè¯·è¡¥å…¨æˆ–è°ƒæ•´é˜¶æ®µã€‚'
                },
                manual: {
                    title: 'å¾·å·æ‰‘å…‹æ¸¸æˆæ‰‹å†Œ',
                    basicRules: 'åŸºæœ¬è§„åˆ™',
                    basicRulesText: 'å¾·å·æ‰‘å…‹ï¼ˆTexas Hold\'emï¼‰æ˜¯ä¸€ç§æµè¡Œçš„æ‰‘å…‹å˜ä½“ï¼Œæ¯ä½ç©å®¶å‘2å¼ åº•ç‰Œï¼Œé€šè¿‡ä¸5å¼ å…¬å…±ç‰Œç»“åˆç»„æˆæœ€ä½³çš„5å¼ ç‰Œå‹ã€‚',
                    gameFlow: 'æ¸¸æˆæµç¨‹',
                    preflop: 'ç¿»å‰ï¼ˆPre-flopï¼‰',
                    preflopDesc: 'æ¯ä½ç©å®¶è·å¾—2å¼ åº•ç‰Œï¼Œæ ¹æ®ç‰ŒåŠ›å†³å®šè·Ÿæ³¨ã€åŠ æ³¨æˆ–å¼ƒç‰Œ',
                    flop: 'ç¿»ç‰Œï¼ˆFlopï¼‰',
                    flopDesc: 'å‘å‡ºå‰3å¼ å…¬å…±ç‰Œï¼Œè¿›è¡Œæ–°ä¸€è½®ä¸‹æ³¨',
                    turn: 'è½¬ç‰Œï¼ˆTurnï¼‰',
                    turnDesc: 'å‘å‡ºç¬¬4å¼ å…¬å…±ç‰Œï¼Œç»§ç»­ä¸‹æ³¨',
                    river: 'æ²³ç‰Œï¼ˆRiverï¼‰',
                    riverDesc: 'å‘å‡ºç¬¬5å¼ å…¬å…±ç‰Œï¼Œæœ€åä¸€è½®ä¸‹æ³¨',
                    showdown: 'æ‘Šç‰Œï¼ˆShowdownï¼‰',
                    showdownDesc: 'æ¯”è¾ƒç‰Œå‹å¤§å°ï¼Œæœ€å¤§ç‰Œå‹è·èƒœ',
                    handRankings: 'ç‰Œå‹æ’åï¼ˆä»å¤§åˆ°å°ï¼‰',
                    royalFlush: 'çš‡å®¶åŒèŠ±é¡º',
                    straightFlush: 'åŒèŠ±é¡º',
                    fourOfKind: 'å››æ¡',
                    fullHouse: 'è‘«èŠ¦',
                    flush: 'åŒèŠ±',
                    straight: 'é¡ºå­',
                    threeOfKind: 'ä¸‰æ¡',
                    twoPair: 'ä¸¤å¯¹',
                    onePair: 'ä¸€å¯¹',
                    highCard: 'é«˜ç‰Œ',
                    keyConcepts: 'å…³é”®æ¦‚å¿µ',
                    potOdds: 'åº•æ± èµ”ç‡ï¼ˆPot Oddsï¼‰',
                    potOddsDesc: 'å½“å‰è·Ÿæ³¨æ‰€éœ€ç­¹ç ä¸åº•æ± å¤§å°çš„æ¯”ä¾‹',
                    impliedOdds: 'éšå«èµ”ç‡ï¼ˆImplied Oddsï¼‰',
                    impliedOddsDesc: 'è€ƒè™‘åç»­å¯èƒ½èµ¢å¾—ç­¹ç çš„èµ”ç‡',
                    position: 'ä½ç½®ï¼ˆPositionï¼‰',
                    positionDesc: 'ç›¸å¯¹äºåº„å®¶ä½ç½®ï¼Œåä½ç½®æœ‰ä¿¡æ¯ä¼˜åŠ¿',
                    spr: 'ç­¹ç -åº•æ± æ¯”ï¼ˆSPRï¼‰',
                    sprDesc: 'æœ‰æ•ˆç­¹ç é™¤ä»¥åº•æ± å¤§å°',
                    draws: 'å¬ç‰Œï¼ˆDrawï¼‰',
                    drawsDesc: 'éœ€è¦ç‰¹å®šç‰Œæ‰èƒ½æˆç‰Œçš„ç‰Œå‹',
                    positions: 'ä½ç½®è¯¦è§£',
                    positionsIntro: 'åœ¨å¾·å·æ‰‘å…‹ä¸­ï¼Œä½ ç›¸å¯¹äºåº„å®¶æŒ‰é’®çš„ä½ç½®å†³å®šäº†è¡ŒåŠ¨é¡ºåºï¼Œæ˜¯å½±å“ç­–ç•¥çš„å…³é”®å› ç´ ï¼š',
                    earlyPositions: 'å‰ä½ï¼ˆEarly Positionï¼‰- æœ€å…ˆè¡ŒåŠ¨',
                    utg: 'UTGï¼ˆæªå£ä½ï¼‰',
                    utgDesc: 'ç¿»å‰ç¬¬ä¸€ä¸ªè¡ŒåŠ¨ï¼Œä¿¡æ¯æœ€å°‘ï¼Œéœ€è¦æœ€å¼ºçš„ç‰Œ',
                    utg1: 'UTG+1',
                    utg1Desc: 'ç¬¬äºŒä¸ªè¡ŒåŠ¨ä½ç½®ï¼Œä»ç„¶éœ€è¦è¾ƒå¼ºæ‰‹ç‰Œ',
                    utg2: 'UTG+2',
                    utg2Desc: 'å¯ä»¥ç•¥å¾®æ”¾å®½æ‰‹ç‰Œè¦æ±‚',
                    middlePositions: 'ä¸­ä½ï¼ˆMiddle Positionï¼‰',
                    mp1: 'MP1ï¼ˆä¸­é—´ä½1ï¼‰',
                    mp1Desc: 'å¯ä»¥ç©æ›´å¤šè¾¹é™…æ‰‹ç‰Œ',
                    mp2: 'MP2ï¼ˆä¸­é—´ä½2ï¼‰',
                    mp2Desc: 'ä½ç½®å¼€å§‹å˜å¾—æœ‰åˆ©',
                    mp3: 'MP3ï¼ˆä¸­é—´ä½3ï¼‰',
                    mp3Desc: 'æ¥è¿‘æ™šä½çš„ä¼˜åŠ¿',
                    latePositions: 'åä½ï¼ˆLate Positionï¼‰- ä¿¡æ¯ä¼˜åŠ¿',
                    lj: 'LJï¼ˆåŠ«åŒªä½ï¼‰',
                    ljDesc: 'å¯ä»¥è§‚å¯Ÿå‰é¢ç©å®¶è¡ŒåŠ¨åå†³ç­–',
                    hj: 'HJï¼ˆåŠ«æŒä½ï¼‰',
                    hjDesc: 'éå¸¸æœ‰åˆ©çš„ä½ç½®ï¼Œå¯ä»¥å·ç›²',
                    co: 'COï¼ˆæˆªæ–­ä½ï¼‰',
                    coDesc: 'ä»…æ¬¡äºæŒ‰é’®ä½çš„ä¼˜åŠ¿ä½ç½®',
                    btn: 'BTNï¼ˆæŒ‰é’®ä½ï¼‰',
                    btnDesc: 'ç¿»åæ°¸è¿œæœ€åè¡ŒåŠ¨ï¼Œæœ€ä½³ä½ç½®',
                    blindPositions: 'ç›²æ³¨ä½ï¼ˆBlind Positionsï¼‰',
                    sb: 'SBï¼ˆå°ç›²ä½ï¼‰',
                    sbDesc: 'ç¿»åç¬¬ä¸€ä¸ªè¡ŒåŠ¨ï¼Œä½ç½®æœ€å·®ä½†å·²æŠ•å…¥ä¸€åŠå¤§ç›²',
                    bb: 'BBï¼ˆå¤§ç›²ä½ï¼‰',
                    bbDesc: 'ç¿»å‰æœ€åè¡ŒåŠ¨ï¼Œç¿»åç¬¬äºŒä¸ªè¡ŒåŠ¨',
                    positionStrategy: 'ä½ç½®ç­–ç•¥è¦ç‚¹',
                    tip1: 'å‰ä½éœ€è¦æ›´å¼ºçš„èµ·æ‰‹ç‰Œï¼Œå› ä¸ºåé¢è¿˜æœ‰å¾ˆå¤šç©å®¶è¦è¡ŒåŠ¨',
                    tip2: 'åä½å¯ä»¥ç©æ›´å¤šæŠ•æœºæ€§æ‰‹ç‰Œï¼Œè§‚å¯Ÿå¯¹æ‰‹è¡ŒåŠ¨åå†å†³ç­–',
                    tip3: 'æŒ‰é’®ä½æ˜¯æœ€æœ‰åˆ©ä½ç½®ï¼Œå¯ä»¥ç”¨æ›´å®½çš„èŒƒå›´åŠ æ³¨å’Œå·ç›²',
                    tip4: 'ç›²æ³¨ä½ç½®ç¿»åä¸åˆ©ï¼Œä½†ç¿»å‰å·²æœ‰æŠ•å…¥è¦è€ƒè™‘åº•æ± èµ”ç‡',
                    strategies: 'å¸¸ç”¨ç­–ç•¥æ¦‚å¿µ',
                    tag: 'ç´§å‡¶ï¼ˆTAGï¼‰',
                    tagDesc: 'åªç©å¼ºç‰Œä½†ç©å¾—æ¿€è¿›',
                    lag: 'æ¾å‡¶ï¼ˆLAGï¼‰',
                    lagDesc: 'ç©è¾ƒå¤šç‰Œå‹ä¸”æ¿€è¿›ä¸‹æ³¨',
                    valueBet: 'ä»·å€¼ä¸‹æ³¨',
                    valueBetDesc: 'æœ‰å¼ºç‰Œæ—¶ä¸‹æ³¨è·å–ä»·å€¼',
                    bluff: 'è¯ˆå”¬ï¼ˆBluffï¼‰',
                    bluffDesc: 'ç”¨å¼±ç‰Œä¸‹æ³¨è¿«ä½¿å¯¹æ‰‹å¼ƒç‰Œ',
                    semiBluff: 'åŠè¯ˆå”¬',
                    semiBluffDesc: 'ç”¨å¬ç‰Œä¸‹æ³¨ï¼Œæ—¢å¯èƒ½æˆç‰Œä¹Ÿå¯èƒ½è®©å¯¹æ‰‹å¼ƒç‰Œ',
                    startingHands: 'æ–°æ‰‹èµ·æ‰‹ç‰Œå»ºè®®',
                    startingHandsIntro: 'ä½œä¸ºæ–°æ‰‹ï¼Œå»ºè®®åªç©ä»¥ä¸‹å¼ºç‰Œï¼Œé¿å…å¤æ‚å†³ç­–ï¼š',
                    premiumHands: 'é¡¶çº§å¼ºç‰Œï¼ˆä»»ä½•ä½ç½®éƒ½å¯ä»¥ç©ï¼‰',
                    strongHands: 'å¼ºç‰Œï¼ˆä¸­åä½å¯ä»¥ç©ï¼‰',
                    speculativeHands: 'æŠ•æœºç‰Œï¼ˆä»…åä½è€ƒè™‘ï¼‰',
                    handTips: 'ğŸ’¡ "s"è¡¨ç¤ºåŒèŠ±è‰²ï¼Œ"o"è¡¨ç¤ºä¸åŒèŠ±è‰²ã€‚æ–°æ‰‹å»ºè®®ï¼šå‰ä½åªç©é¡¶çº§å¼ºç‰Œï¼Œåä½å¯ä»¥é€‚å½“æ”¾å®½ã€‚'
                }
            }
        };

        const positionLabels = {
            BTN: { en: 'Button (BTN)', zh: 'æŒ‰é’®ä½ (BTN)' },
            CO: { en: 'Cutoff (CO)', zh: 'æˆªæ–­ä½ (CO)' },
            HJ: { en: 'Hijack (HJ)', zh: 'åŠ«æŒä½ (HJ)' },
            LJ: { en: 'Lojack (LJ)', zh: 'åŠ«åŒªä½ (LJ)' },
            MP3: { en: 'Middle Position 3', zh: 'ä¸­é—´ä½3' },
            MP2: { en: 'Middle Position 2', zh: 'ä¸­é—´ä½2' },
            MP1: { en: 'Middle Position 1', zh: 'ä¸­é—´ä½1' },
            UTG2: { en: 'UTG +2', zh: 'æªå£+2' },
            UTG1: { en: 'UTG +1', zh: 'æªå£+1' },
            UTG: { en: 'Under the Gun (UTG)', zh: 'æªå£ä½ (UTG)' },
            SB: { en: 'Small Blind (SB)', zh: 'å°ç›²ä½ (SB)' },
            BB: { en: 'Big Blind (BB)', zh: 'å¤§ç›²ä½ (BB)' }
        };

        const streetBoardCounts = {
            PREFLOP: 0,
            FLOP: 3,
            TURN: 4,
            RIVER: 5
        };

        const actionLabels = {
            en: {
                fold: 'Fold',
                check: 'Check',
                call: 'Call',
                raise: 'Raise',
                all_in: 'All-in'
            },
            zh: {
                fold: 'å¼ƒç‰Œ',
                check: 'è¿‡ç‰Œ',
                call: 'è·Ÿæ³¨',
                raise: 'åŠ æ³¨',
                all_in: 'å…¨ä¸‹'
            }
        };

        const suits = [
            { key: 'spades', symbol: 'â™ ', code: 's' },
            { key: 'hearts', symbol: 'â™¥', code: 'h' },
            { key: 'diamonds', symbol: 'â™¦', code: 'd' },
            { key: 'clubs', symbol: 'â™£', code: 'c' }
        ];

        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];

        const percentFactorKeys = new Set([
            'equity',
            'pot_odds',
            'hand_strength',
            'position_factor',
            'fold_equity',
            'board_wetness',
            'betting_pressure',
            'board_pressure',
            'range_advantage',
            'psychological_pressure',
            'bluff_tendency',
            'opponent_aggression',
            'opponent_tightness',
            'draw_probability',
            'implied_odds',
            'pot_commitment'
        ]);

        const state = {
            language: 'zh',
            heroCards: [null, null],
            board: [null, null, null, null, null],
            street: 'PREFLOP',
            selectedSlot: null,
            position: 'BTN',
            lastResult: null,
            apiStatus: 'idle',
            opponent: {
                aggression: 0.6,
                tightness: 0.5,
                bluff: 0.3,
                confidence: 0.6,
                tilt: 0.4,
                betPct: 65,
                action: {
                    street: 'PREFLOP',
                    type: 'bet',
                    amount: null,
                    pot: null
                },
                notes: ''
            },
            opponentProfile: null
        };

        window.addEventListener('DOMContentLoaded', () => {
            deckGrid = document.getElementById('deckGrid');
            heroSlots = document.getElementById('heroSlots');
            boardSlots = document.getElementById('boardSlots');
            streetOptions = document.getElementById('streetOptions');
            positionSelect = document.getElementById('positionSelect');
            riskSlider = document.getElementById('riskSlider');
            riskValue = document.getElementById('riskValue');
            langToggle = document.getElementById('langToggle');
            apiConfigBtn = document.getElementById('apiConfigBtn');
            apiStatusLabel = document.getElementById('apiStatusLabel');
            loadingIndicator = document.getElementById('loading');
            actionValue = document.getElementById('actionValue');
            confidenceValue = document.getElementById('confidenceValue');
            evValue = document.getElementById('evValue');
            resultBanner = document.getElementById('resultBanner');
            explanationBox = document.getElementById('explanationBox');
            factorsGrid = document.getElementById('factorsGrid');
            errorBox = document.getElementById('errorBox');
            summaryGrid = document.getElementById('summaryGrid');
            opponentInsightsPanel = document.getElementById('opponentInsights');
            opponentArchetype = document.getElementById('opponentArchetype');
            opponentSummary = document.getElementById('opponentSummary');
            opponentNotesContainer = document.getElementById('opponentNotes');
            opponentAggressionMetric = document.getElementById('opponentAggressionMetric');
            opponentBettingMetric = document.getElementById('opponentBettingMetric');
            opponentPsychologyMetric = document.getElementById('opponentPsychologyMetric');
            opponentRangeMetric = document.getElementById('opponentRangeMetric');
            opAggressionInput = document.getElementById('opAggressionInput');
            opTightnessInput = document.getElementById('opTightnessInput');
            opBluffInput = document.getElementById('opBluffInput');
            opConfidenceInput = document.getElementById('opConfidenceInput');
            opTiltInput = document.getElementById('opTiltInput');
            opBetPctInput = document.getElementById('opBetPctInput');
            opActionStreet = document.getElementById('opActionStreet');
            opActionType = document.getElementById('opActionType');
            opActionAmount = document.getElementById('opActionAmount');
            opActionPot = document.getElementById('opActionPot');
            opNotesInput = document.getElementById('opNotesInput');
            opAggressionValue = document.getElementById('opAggressionValue');
            opTightnessValue = document.getElementById('opTightnessValue');
            opBluffValue = document.getElementById('opBluffValue');
            opConfidenceValue = document.getElementById('opConfidenceValue');
            opTiltValue = document.getElementById('opTiltValue');

            // æ¸¸æˆæ‰‹å†Œç›¸å…³å…ƒç´ 
            const gameManualBtn = document.getElementById('gameManualBtn');
            const gameManualModal = document.getElementById('gameManualModal');
            const closeManualBtn = document.getElementById('closeManualBtn');

            // æ–°æ‰‹æç¤ºç›¸å…³å…ƒç´ 
            const beginnerTip = document.getElementById('beginnerTip');
            const dismissTip = document.getElementById('dismissTip');

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡è®¿é—®
            const hasVisited = localStorage.getItem('qpds_visited');
            if (hasVisited) {
                beginnerTip.classList.add('hidden');
            }

            // æ–°æ‰‹æç¤ºå…³é—­äº‹ä»¶
            dismissTip.addEventListener('click', () => {
                beginnerTip.classList.add('hidden');
                localStorage.setItem('qpds_visited', 'true');
            });

            // æ¸¸æˆæ‰‹å†Œäº‹ä»¶ç›‘å¬
            gameManualBtn.addEventListener('click', () => {
                gameManualModal.classList.add('show');
            });

            closeManualBtn.addEventListener('click', () => {
                gameManualModal.classList.remove('show');
            });

            // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
            gameManualModal.addEventListener('click', (e) => {
                if (e.target === gameManualModal) {
                    gameManualModal.classList.remove('show');
                }
            });

            // ESCé”®å…³é—­æ¨¡æ€æ¡†
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && gameManualModal.classList.contains('show')) {
                    gameManualModal.classList.remove('show');
                }
            });

            bootstrap();
        });

        function t(key) {
            const parts = key.split('.');
            let cursor = translations[state.language];
            for (const part of parts) {
                if (cursor && part in cursor) {
                    cursor = cursor[part];
                } else {
                    return key;
                }
            }
            return cursor;
        }

        function translatePage() {
            document.documentElement.lang = state.language;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const text = t(key);
                if (typeof text === 'string') {
                    el.textContent = text;
                }
            });

            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                const text = t(key);
                if (typeof text === 'string') {
                    el.setAttribute('placeholder', text);
                }
            });

            // Re-translate stage labels
            streetOptions.querySelectorAll('label').forEach(label => {
                const street = label.getAttribute('data-street');
                const span = label.querySelector('span');
                if (span) {
                    span.textContent = t(`streets.${street}`);
                }
            });

            // Rebuild position select options
            const selected = positionSelect.value;
            positionSelect.innerHTML = '';
            Object.entries(positionLabels).forEach(([value, labels]) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = labels[state.language];
                if (value === selected) {
                    option.selected = true;
                }
                positionSelect.appendChild(option);
            });

            langToggle.textContent = state.language === 'en' ? 'ä¸­æ–‡' : 'English';

            refreshSummary();

            if (state.lastResult) {
                const snapshot = state.lastResult;
                if (snapshot.kind === 'recommendation') {
                    showRecommendation(snapshot.data);
                } else if (snapshot.kind === 'equity') {
                    showEquityOnly(snapshot.data);
                }
            }

            updateApiStatusLabel();
        }

        function getStatusCopy() {
            const fallback = {
                apiLabel: 'API',
                checking: 'checkingâ€¦',
                connected: 'online',
                failed: 'unreachable'
            };
            return (translations[state.language] && translations[state.language].status) || fallback;
        }

        function updateApiStatusLabel(statusOverride) {
            if (!apiStatusLabel) {
                return;
            }
            const copy = getStatusCopy();
            const status = statusOverride || state.apiStatus;
            let suffix = '';
            if (status === 'checking') {
                suffix = copy.checking;
            } else if (status === 'ok') {
                suffix = copy.connected;
            } else if (status === 'error') {
                suffix = copy.failed;
            }

            const parts = [`${copy.apiLabel}: ${API_URL}`];
            if (suffix) {
                parts.push(`(${suffix})`);
            }
            apiStatusLabel.textContent = parts.join(' ');
        }

        function getBackendUnavailableMessage() {
            if (state.language === 'zh') {
                return `æ— æ³•è¿æ¥åç«¯æœåŠ¡ï¼š${API_URL}ã€‚è¯·å¯åŠ¨æœ¬åœ° Flask åç«¯ï¼Œæˆ–ç‚¹å‡»â€œâš™ï¸ APIé…ç½®â€æŒ‰é’®è®¾ç½®å·²éƒ¨ç½²çš„åœ°å€ã€‚`;
            }
            return `Cannot reach backend service at ${API_URL}. Start the local Flask backend or use the âš™ï¸ API button to point to your deployed service.`;
        }

        function initApiConfig() {
            if (!apiConfigBtn) {
                return;
            }
            apiConfigBtn.addEventListener('click', () => {
                const promptMessage = t('prompts.apiBase');
                const input = window.prompt(promptMessage, API_URL);
                if (input === null) {
                    return;
                }

                const trimmed = input.trim();
                if (!trimmed) {
                    localStorage.removeItem(API_STORAGE_KEY);
                    API_URL = resolveApiUrl({ skipQuery: true });
                    state.apiStatus = 'idle';
                    updateApiStatusLabel();
                    window.alert(t('prompts.apiBaseCleared'));
                    initHealthCheck({ silent: true });
                    return;
                }

                const sanitized = sanitizeApiUrl(trimmed);
                if (!sanitized) {
                    window.alert(t('prompts.apiBaseInvalid'));
                    return;
                }

                API_URL = sanitized;
                localStorage.setItem(API_STORAGE_KEY, API_URL);
                state.apiStatus = 'checking';
                updateApiStatusLabel('checking');
                initHealthCheck();
            });

            updateApiStatusLabel();
        }

        function buildDeck() {
            deckGrid.innerHTML = '';
            suits.forEach(suit => {
                const row = document.createElement('div');
                row.className = 'deck-row';
                row.dataset.suit = suit.key;

                const label = document.createElement('div');
                label.className = 'deck-suit';
                label.textContent = suit.symbol;
                row.appendChild(label);
                ranks.forEach(rank => {
                    const cardCode = `${rank}${suit.code}`;
                    const button = document.createElement('button');
                    button.className = 'card-button';
                    button.dataset.card = `${rank}${suit.code}`;
                    button.dataset.suit = suit.key;
                    button.innerHTML = `${rank}${suit.symbol}`;
                    button.addEventListener('click', () => onDeckCardSelected(cardCode));
                    row.appendChild(button);
                });
                deckGrid.appendChild(row);
            });
            updateDeckAvailability();
        }

        function createSlotElement(type, index, cardCode) {
            const slot = document.createElement('div');
            slot.className = 'card-slot';
            slot.dataset.type = type;
            slot.dataset.index = index;
            const disabled = type === 'board' && index >= streetBoardCounts[state.street];
            slot.dataset.disabled = disabled ? 'true' : 'false';
            if (disabled) {
                return slot;
            }

            const label = document.createElement('span');
            label.className = 'card-label';
            label.textContent = type === 'hero' ? `P${index + 1}` : `B${index + 1}`;
            slot.appendChild(label);

            if (cardCode) {
                slot.dataset.filled = 'true';
                slot.textContent = cardCode.toUpperCase();
                slot.appendChild(label);

                const tag = document.createElement('div');
                tag.className = 'remove-tag';
                tag.textContent = 'âœ•';
                tag.addEventListener('click', (event) => {
                    event.stopPropagation();
                    clearSlot(type, index);
                });
                slot.appendChild(tag);
            } else {
                slot.dataset.filled = 'false';
                slot.appendChild(label);
            }

            if (state.selectedSlot && state.selectedSlot.type === type && state.selectedSlot.index === index) {
                slot.dataset.selected = 'true';
            }

            slot.addEventListener('click', () => onSlotClick(type, index));
            return slot;
        }

        function renderSlots() {
            heroSlots.innerHTML = '';
            state.heroCards.forEach((card, index) => {
                heroSlots.appendChild(createSlotElement('hero', index, card));
            });

            boardSlots.innerHTML = '';
            state.board.forEach((card, index) => {
                boardSlots.appendChild(createSlotElement('board', index, card));
            });

            refreshSummary();
        }

        function onSlotClick(type, index) {
            const disabled = type === 'board' && index >= streetBoardCounts[state.street];
            if (disabled) {
                return;
            }

            const currentCard = type === 'hero' ? state.heroCards[index] : state.board[index];
            if (currentCard) {
                clearSlot(type, index);
                return;
            }

            state.selectedSlot = { type, index };
            renderSlots();
        }

        function clearSlot(type, index) {
            if (type === 'hero') {
                state.heroCards[index] = null;
            } else {
                state.board[index] = null;
            }
            if (state.selectedSlot && state.selectedSlot.type === type && state.selectedSlot.index === index) {
                state.selectedSlot = null;
            }
            updateDeckAvailability();
            renderSlots();
        }

        function isCardUsed(cardCode) {
            const allCards = [...state.heroCards, ...state.board];
            return allCards.includes(cardCode.toLowerCase());
        }

        function findNextAvailableSlot() {
            for (let i = 0; i < state.heroCards.length; i += 1) {
                if (!state.heroCards[i]) {
                    return { type: 'hero', index: i };
                }
            }
            const allowedBoard = streetBoardCounts[state.street];
            for (let i = 0; i < allowedBoard; i += 1) {
                if (!state.board[i]) {
                    return { type: 'board', index: i };
                }
            }
            return null;
        }

        function onDeckCardSelected(cardCode) {
            if (isCardUsed(cardCode)) {
                return;
            }

            let targetSlot = state.selectedSlot;
            if (!targetSlot) {
                targetSlot = findNextAvailableSlot();
            }
            if (!targetSlot) {
                return;
            }

            if (targetSlot.type === 'hero') {
                state.heroCards[targetSlot.index] = cardCode.toLowerCase();
            } else {
                state.board[targetSlot.index] = cardCode.toLowerCase();
            }

            state.selectedSlot = findNextAvailableSlot();
            updateDeckAvailability();
            renderSlots();
        }

        function updateDeckAvailability() {
            const used = new Set([...state.heroCards, ...state.board].filter(Boolean));
            deckGrid.querySelectorAll('.card-button').forEach(button => {
                const code = (button.dataset.card || '').toLowerCase();
                button.dataset.used = used.has(code) ? 'true' : 'false';
            });
        }

        function onStreetChange(value) {
            state.street = value;
            // Trim board cards beyond allowed count
            const allowed = streetBoardCounts[value];
            state.board = state.board.map((card, index) => (index < allowed ? card : null));
            if (state.selectedSlot && state.selectedSlot.type === 'board' && state.selectedSlot.index >= allowed) {
                state.selectedSlot = null;
            }
            renderSlots();
        }

        function resetBoardSelections() {
            state.heroCards = [null, null];
            state.board = [null, null, null, null, null];
            state.street = 'PREFLOP';
            state.selectedSlot = null;
            streetOptions.querySelectorAll('label').forEach(label => {
                label.classList.toggle('active', label.getAttribute('data-street') === 'PREFLOP');
                label.querySelector('input').checked = label.getAttribute('data-street') === 'PREFLOP';
            });
            renderSlots();
            updateDeckAvailability();
            clearResult();
            showError('');
            state.opponent = {
                aggression: 0.6,
                tightness: 0.5,
                bluff: 0.3,
                confidence: 0.6,
                tilt: 0.4,
                betPct: 65,
                action: {
                    street: 'PREFLOP',
                    type: 'bet',
                    amount: null,
                    pot: null
                },
                notes: ''
            };
            if (opAggressionInput) {
                opAggressionInput.value = 6;
                opAggressionInput.dispatchEvent(new Event('input'));
            }
            if (opTightnessInput) {
                opTightnessInput.value = 5;
                opTightnessInput.dispatchEvent(new Event('input'));
            }
            if (opBluffInput) {
                opBluffInput.value = 3;
                opBluffInput.dispatchEvent(new Event('input'));
            }
            if (opConfidenceInput) {
                opConfidenceInput.value = 6;
                opConfidenceInput.dispatchEvent(new Event('input'));
            }
            if (opTiltInput) {
                opTiltInput.value = 4;
                opTiltInput.dispatchEvent(new Event('input'));
            }
            if (opBetPctInput) {
                opBetPctInput.value = 65;
                opBetPctInput.dispatchEvent(new Event('input'));
            }
            if (opActionStreet) {
                opActionStreet.value = 'PREFLOP';
                opActionStreet.dispatchEvent(new Event('change'));
            }
            if (opActionType) {
                opActionType.value = 'bet';
                opActionType.dispatchEvent(new Event('change'));
            }
            if (opActionAmount) {
                opActionAmount.value = '';
                opActionAmount.dispatchEvent(new Event('input'));
            }
            if (opActionPot) {
                opActionPot.value = '';
                opActionPot.dispatchEvent(new Event('input'));
            }
            if (opNotesInput) {
                opNotesInput.value = '';
                state.opponent.notes = '';
            }
            refreshSummary();
        }

        function buildOpponentObservationPayload() {
            const { action } = state.opponent;
            if (!action || !action.street || !action.type) {
                return null;
            }
            const payload = {
                street: action.street,
                action: action.type
            };
            if (Number.isFinite(action.amount) && Number.isFinite(action.pot) && action.pot > 0) {
                payload.amount = action.amount;
                payload.pot = action.pot;
            }
            return payload;
        }

        function getOpponentStatsPayload() {
            const stats = {
                aggression: state.opponent.aggression,
                tightness: state.opponent.tightness,
                bluff_frequency: state.opponent.bluff,
                recent_bet_pct: state.opponent.betPct,
                confidence: state.opponent.confidence,
                tilt: state.opponent.tilt
            };

            const observation = buildOpponentObservationPayload();
            if (observation) {
                stats.observations = [observation];
            }

            if (state.opponent.notes && state.opponent.notes.trim()) {
                stats.notes = state.opponent.notes.trim();
            }

            return stats;
        }

        function buildOpponentPreviousActions() {
            const observation = buildOpponentObservationPayload();
            if (!observation || observation.amount === undefined) {
                return null;
            }
            return [{
                actor: 'villain',
                street: observation.street,
                action: observation.action,
                amount: observation.amount,
                pot: observation.pot
            }];
        }

        function gatherGameState() {
            const opponentStats = getOpponentStatsPayload();
            const previousActions = buildOpponentPreviousActions();

            const payload = {
                hero_cards: state.heroCards.filter(Boolean).map(card => card.toUpperCase()),
                board: state.board.filter((card, index) => index < streetBoardCounts[state.street] && card).map(card => card.toUpperCase()),
                pot_size: parseFloat(document.getElementById('potInput').value) || 0,
                to_call: parseFloat(document.getElementById('toCallInput').value) || 0,
                hero_stack: parseFloat(document.getElementById('heroStackInput').value) || 0,
                villain_stack: parseFloat(document.getElementById('villainStackInput').value) || 0,
                position: positionSelect.value,
                street: state.street,
                villain_range: document.getElementById('rangeInput').value || null,
                risk_preference: parseFloat(riskSlider.value) || 5,
                opponent_stats: opponentStats
            };

            if (previousActions) {
                payload.previous_actions = previousActions;
            }

            return payload;
        }

        function showLoading() {
            loadingIndicator.classList.add('active');
            resultBanner.style.display = 'none';
            explanationBox.style.display = 'none';
            factorsGrid.innerHTML = '';
        }

        function hideLoading() {
            loadingIndicator.classList.remove('active');
        }

        function clearResult() {
            resultBanner.style.display = 'none';
            explanationBox.style.display = 'none';
            factorsGrid.innerHTML = '';
            confidenceValue.textContent = '-';
            evValue.textContent = '-';
            state.lastResult = null;
            if (opponentInsightsPanel) {
                opponentInsightsPanel.style.display = 'none';
                if (opponentArchetype) opponentArchetype.textContent = '';
                if (opponentSummary) opponentSummary.textContent = '';
                if (opponentAggressionMetric) opponentAggressionMetric.textContent = '-';
                if (opponentBettingMetric) opponentBettingMetric.textContent = '-';
                if (opponentPsychologyMetric) opponentPsychologyMetric.textContent = '-';
                if (opponentRangeMetric) opponentRangeMetric.textContent = '-';
                if (opponentNotesContainer) opponentNotesContainer.innerHTML = '';
            }
            state.opponentProfile = null;
        }

        function formatPercent(value, digits = 1) {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                return '-';
            }
            return `${(value * 100).toFixed(digits)}%`;
        }

        function formatFactorValue(key, value) {
            if (value === null || value === undefined) {
                return '-';
            }
            if (percentFactorKeys.has(key)) {
                return formatPercent(value);
            }
            if (key === 'outs') {
                return `${Math.round(value)}`;
            }
            return `${Number(value).toFixed(2)}`;
        }

        function displayFactors(factors) {
            if (!factors) {
                return;
            }
            const keys = [
                'equity',
                'hand_strength',
                'range_advantage',
                'opponent_aggression',
                'opponent_tightness',
                'betting_pressure',
                'board_wetness',
                'board_pressure',
                'psychological_pressure',
                'fold_equity',
                'bluff_tendency',
                'pot_odds',
                'position_factor',
                'stack_to_pot_ratio',
                'effective_stack',
                'implied_odds',
                'pot_commitment',
                'outs',
                'draw_probability'
            ];
            factorsGrid.innerHTML = '';
            keys.forEach(key => {
                if (factors[key] === undefined) {
                    return;
                }
                const card = document.createElement('div');
                card.className = 'factor-card';

                const name = document.createElement('div');
                name.className = 'factor-name';
                const factorName = translations[state.language].factors.names[key] || key;
                name.textContent = factorName;

                const value = document.createElement('div');
                value.className = 'factor-value';
                value.textContent = formatFactorValue(key, factors[key]);

                card.appendChild(name);
                card.appendChild(value);
                factorsGrid.appendChild(card);
            });
        }

        function renderOpponentInsights(profile, factors) {
            if (!opponentInsightsPanel) {
                return;
            }

            let resolved = profile;
            if (!resolved && factors) {
                resolved = {
                    classification: factors.opponent_classification,
                    summary: factors.opponent_summary,
                    notes: factors.opponent_notes,
                    aggression_index: factors.opponent_aggression,
                    betting_pressure: factors.betting_pressure,
                    psychological_pressure: factors.psychological_pressure,
                    range_advantage: factors.range_advantage
                };
            }

            if (!resolved || (!resolved.classification && !resolved.summary)) {
                opponentInsightsPanel.style.display = 'none';
                state.opponentProfile = null;
                return;
            }

            state.opponentProfile = resolved;
            opponentInsightsPanel.style.display = 'block';

            if (opponentArchetype) {
                opponentArchetype.textContent = resolved.classification || '';
            }
            if (opponentSummary) {
                opponentSummary.textContent = resolved.summary || '';
            }
            if (opponentAggressionMetric) {
                opponentAggressionMetric.textContent = formatPercent(resolved.aggression_index ?? factors?.opponent_aggression ?? 0, 1);
            }
            if (opponentBettingMetric) {
                opponentBettingMetric.textContent = formatPercent(resolved.betting_pressure ?? factors?.betting_pressure ?? 0, 1);
            }
            if (opponentPsychologyMetric) {
                opponentPsychologyMetric.textContent = formatPercent(resolved.psychological_pressure ?? factors?.psychological_pressure ?? 0, 1);
            }
            if (opponentRangeMetric) {
                opponentRangeMetric.textContent = formatPercent(resolved.range_advantage ?? factors?.range_advantage ?? 0, 1);
            }

            if (opponentNotesContainer) {
                opponentNotesContainer.innerHTML = '';
                const notes = [];
                if (Array.isArray(resolved.notes)) {
                    notes.push(...resolved.notes);
                } else if (resolved.notes) {
                    notes.push(resolved.notes);
                }
                if (factors?.opponent_notes && Array.isArray(factors.opponent_notes)) {
                    notes.push(...factors.opponent_notes);
                }

                if (notes.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'insight-note';
                    empty.textContent = state.language === 'zh' ? 'æš‚æ— æ›´å¤šçº¿ç´¢ï¼Œä¿æŒè§‚å¯Ÿã€‚' : 'No additional reads yet â€” keep observing.';
                    opponentNotesContainer.appendChild(empty);
                } else {
                    notes.slice(0, 4).forEach(note => {
                        const item = document.createElement('div');
                        item.className = 'insight-note';
                        item.textContent = note;
                        opponentNotesContainer.appendChild(item);
                    });
                }
            }
        }

        function getNumericValue(id) {
            const el = document.getElementById(id);
            if (!el) {
                return 0;
            }
            return parseFloat(el.value) || 0;
        }

        function formatChips(amount) {
            const fixed = Number(amount).toFixed(2);
            return fixed.replace(/\.00$/, '');
        }

        function refreshSummary() {
            if (!summaryGrid) {
                return;
            }

            const summaryLabels = translations[state.language].summary.items;
            const summaryData = [
                { key: 'pot', value: formatChips(getNumericValue('potInput')) },
                { key: 'toCall', value: formatChips(getNumericValue('toCallInput')) },
                { key: 'heroStack', value: formatChips(getNumericValue('heroStackInput')) },
                { key: 'villainStack', value: formatChips(getNumericValue('villainStackInput')) },
                { key: 'street', value: t(`streets.${state.street}`) },
                { key: 'position', value: positionLabels[state.position][state.language] },
                { key: 'risk', value: `${riskSlider ? riskSlider.value : 5}/10` },
                { key: 'opponentModel', value: getOpponentSummaryText() }
            ];

            summaryGrid.innerHTML = '';

            summaryData.forEach(({ key, value }) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'summary-item';

                const label = document.createElement('span');
                label.textContent = summaryLabels[key] || key;

                const strong = document.createElement('strong');
                strong.textContent = value;

                wrapper.appendChild(label);
                wrapper.appendChild(strong);
                summaryGrid.appendChild(wrapper);
            });
        }

        function getOpponentSummaryText() {
            const aggressionScore = Math.round((state.opponent.aggression || 0) * 10);
            const tightnessScore = Math.round((state.opponent.tightness || 0) * 10);
            if (state.language === 'zh') {
                return `æ¿€è¿› ${aggressionScore}/10ï½œèŒƒå›´ ${tightnessScore}/10`;
            }
            return `Agg ${aggressionScore}/10 Â· Range ${tightnessScore}/10`;
        }

        function translateAction(action) {
            if (!action) {
                return '-';
            }
            const key = action.toLowerCase();
            return actionLabels[state.language][key] || action.toUpperCase();
        }

        function showRecommendation(data) {
            state.lastResult = { kind: 'recommendation', data };
            const actionText = translateAction(data.action);
            if (data.amount && data.action && data.action.toLowerCase() === 'raise' && Number(data.amount) > 0) {
                actionValue.textContent = `${actionText} ${formatChips(data.amount)}`;
            } else {
                actionValue.textContent = actionText;
            }

            if (typeof data.confidence === 'number') {
                confidenceValue.textContent = `${(data.confidence * 100).toFixed(1)}%`;
            } else {
                confidenceValue.textContent = '-';
            }

            if (typeof data.expected_value === 'number') {
                evValue.textContent = formatChips(data.expected_value);
            } else {
                evValue.textContent = '-';
            }

            resultBanner.style.display = 'block';

            if (data.explanation) {
                explanationBox.textContent = data.explanation;
                explanationBox.style.display = 'block';
            } else {
                explanationBox.style.display = 'none';
            }

            displayFactors(data.all_factors || data.factors_used);
            renderOpponentInsights(data.opponent_profile, data.all_factors);
            refreshSummary();
        }

        function showEquityOnly(data) {
            state.lastResult = { kind: 'equity', data };
            const percent = data.win_percentage ? data.win_percentage.toFixed(1) : (data.equity ? (data.equity * 100).toFixed(1) : '-');
            actionValue.textContent = `${percent}%`;
            confidenceValue.textContent = '-';
            evValue.textContent = '-';
            resultBanner.style.display = 'block';
            explanationBox.textContent = state.language === 'zh' ? 'å½“å‰æ‰‹ç‰Œå¯¹è¾“å…¥èŒƒå›´çš„èƒœç‡' : 'Win probability versus the selected range';
            explanationBox.style.display = 'block';
            factorsGrid.innerHTML = '';
            renderOpponentInsights(data.opponent_profile || null, null);
            refreshSummary();
        }

        function showError(message) {
            if (!message) {
                errorBox.textContent = '';
                errorBox.classList.remove('active');
                return;
            }
            errorBox.textContent = message;
            errorBox.classList.add('active');
        }

        function validateBeforeRequest() {
            if (state.heroCards.filter(Boolean).length !== 2) {
                showError(t('errors.missingCards'));
                return false;
            }
            const requiredBoard = streetBoardCounts[state.street];
            if (state.board.filter(Boolean).length !== requiredBoard) {
                showError(t('errors.boardRequirement'));
                return false;
            }
            showError('');
            return true;
        }

        async function request(endpoint, payload) {
            try {
                const response = await fetch(`${API_URL}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    state.apiStatus = 'ok';
                    updateApiStatusLabel('ok');
                    const errorData = await response.json().catch(() => ({}));
                    const message = errorData.error || `HTTP ${response.status}`;
                    throw new Error(message);
                }

                state.apiStatus = 'ok';
                updateApiStatusLabel('ok');
                return response.json();
            } catch (error) {
                if (error instanceof TypeError || error.message === 'Failed to fetch') {
                    state.apiStatus = 'error';
                    updateApiStatusLabel('error');
                    throw new Error(getBackendUnavailableMessage());
                }
                throw error;
            }
        }

        function localizeBackendMessage(message) {
            if (state.language === 'zh') {
                if (message.includes('exactly two hero cards')) {
                    return 'å¾·å·æ‰‘å…‹è§„åˆ™è¦æ±‚ä½ å¿…é¡»æŒæœ‰ä¸¤å¼ ä¸åŒçš„åº•ç‰Œã€‚';
                }
                if (message.includes('Duplicate cards')) {
                    return 'å‡ºç°é‡å¤å¡ç‰Œï¼Œè¯·é‡æ–°é€‰æ‹©ã€‚';
                }
                if (message.includes('community cards cannot exceed five')) {
                    return 'å…¬å…±ç‰Œæœ€å¤šåªèƒ½æœ‰äº”å¼ ã€‚';
                }
                if (message.includes('requires exactly')) {
                    return 'å½“å‰é˜¶æ®µçš„å…¬å…±ç‰Œæ•°é‡ä¸åŒ¹é…ï¼Œè¯·æ ¸å¯¹é˜¶æ®µå’Œç‰Œé¢ã€‚';
                }
            }
            return message;
        }

        async function handleRecommendation() {
            if (!validateBeforeRequest()) {
                return;
            }
            showLoading();
            try {
                const payload = gatherGameState();
                const data = await request('/api/get_recommendation', payload);
                showRecommendation(data);
            } catch (error) {
                showError(localizeBackendMessage(error.message));
            } finally {
                hideLoading();
            }
        }

        async function handleEquityOnly() {
            if (state.heroCards.filter(Boolean).length !== 2) {
                showError(t('errors.missingCards'));
                return;
            }
            showLoading();
            try {
                const payload = gatherGameState();
                const data = await request('/api/get_equity', {
                    hero_cards: payload.hero_cards,
                    board: payload.board,
                    villain_range: payload.villain_range,
                    num_opponents: 1,
                    iterations: 10000
                });
                showEquityOnly(data);
            } catch (error) {
                showError(localizeBackendMessage(error.message));
            } finally {
                hideLoading();
            }
        }

        function initPositionSelect() {
            Object.entries(positionLabels).forEach(([value, labels]) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = labels[state.language];
                positionSelect.appendChild(option);
            });
            positionSelect.value = state.position;

            positionSelect.addEventListener('change', () => {
                state.position = positionSelect.value;
                refreshSummary();
            });
        }

        function initStreetOptions() {
            streetOptions.addEventListener('change', (event) => {
                if (event.target && event.target.name === 'street') {
                    const value = event.target.value;
                    streetOptions.querySelectorAll('label').forEach(label => {
                        label.classList.toggle('active', label.getAttribute('data-street') === value);
                    });
                    onStreetChange(value);
                }
            });
        }

        function initDeckAndSlots() {
            renderSlots();
            buildDeck();
        }

        function initNumericInputs() {
            ['potInput', 'toCallInput', 'heroStackInput', 'villainStackInput'].forEach(id => {
                const el = document.getElementById(id);
                if (!el) {
                    return;
                }
                el.addEventListener('input', refreshSummary);
            });
        }

        function initLanguageToggle() {
            langToggle.addEventListener('click', () => {
                state.language = state.language === 'en' ? 'zh' : 'en';
                translatePage();
                renderSlots();
            });
        }

        function initButtons() {
            document.getElementById('recommendButton').addEventListener('click', handleRecommendation);
            document.getElementById('equityButton').addEventListener('click', handleEquityOnly);
            document.getElementById('resetButton').addEventListener('click', resetBoardSelections);
        }

        function initRiskSlider() {
            riskSlider.addEventListener('input', () => {
                riskValue.textContent = riskSlider.value;
                refreshSummary();
            });

            riskValue.textContent = riskSlider.value;
            refreshSummary();
        }

        function initOpponentControls() {
            if (!opAggressionInput) {
                return;
            }

            const sliderConfigs = [
                { input: opAggressionInput, display: opAggressionValue, key: 'aggression' },
                { input: opTightnessInput, display: opTightnessValue, key: 'tightness' },
                { input: opBluffInput, display: opBluffValue, key: 'bluff' },
                { input: opConfidenceInput, display: opConfidenceValue, key: 'confidence' },
                { input: opTiltInput, display: opTiltValue, key: 'tilt' }
            ];

            sliderConfigs.forEach(({ input, display, key }) => {
                if (!input) {
                    return;
                }
                const apply = () => {
                    const rawValue = Number(input.value || 0);
                    state.opponent[key] = Math.max(0, Math.min(1, rawValue / 10));
                    if (display) {
                        display.textContent = `${rawValue}/10`;
                    }
                    refreshSummary();
                };
                input.addEventListener('input', apply);
                input.value = Math.round((state.opponent[key] || 0) * 10);
                apply();
            });

            if (opBetPctInput) {
                opBetPctInput.value = state.opponent.betPct;
                opBetPctInput.addEventListener('input', () => {
                    const value = Number(opBetPctInput.value || 0);
                    state.opponent.betPct = Math.max(0, Math.min(400, value));
                    refreshSummary();
                });
            }

            if (opActionStreet) {
                opActionStreet.value = state.opponent.action.street;
                opActionStreet.addEventListener('change', () => {
                    state.opponent.action.street = opActionStreet.value;
                    refreshSummary();
                });
            }

            if (opActionType) {
                opActionType.value = state.opponent.action.type;
                opActionType.addEventListener('change', () => {
                    state.opponent.action.type = opActionType.value;
                    refreshSummary();
                });
            }

            if (opActionAmount) {
                opActionAmount.value = state.opponent.action.amount ?? '';
                opActionAmount.addEventListener('input', () => {
                    const value = parseFloat(opActionAmount.value);
                    state.opponent.action.amount = Number.isFinite(value) ? value : null;
                    refreshSummary();
                });
            }

            if (opActionPot) {
                opActionPot.value = state.opponent.action.pot ?? '';
                opActionPot.addEventListener('input', () => {
                    const value = parseFloat(opActionPot.value);
                    state.opponent.action.pot = Number.isFinite(value) ? value : null;
                    refreshSummary();
                });
            }

            if (opNotesInput) {
                opNotesInput.value = state.opponent.notes || '';
                opNotesInput.addEventListener('input', () => {
                    state.opponent.notes = opNotesInput.value;
                    refreshSummary();
                });
            }
        }

        function initHealthCheck(options = {}) {
            const { silent = false } = options;
            state.apiStatus = 'checking';
            updateApiStatusLabel('checking');

            return fetch(`${API_URL}/health`)
                .then((response) => {
                    if (!response.ok) {
                        throw new Error('Health check failed');
                    }
                    state.apiStatus = 'ok';
                    updateApiStatusLabel('ok');
                    if (!silent) {
                        showError('');
                    }
                })
                .catch(() => {
                    state.apiStatus = 'error';
                    updateApiStatusLabel('error');
                    if (!silent) {
                        showError(getBackendUnavailableMessage());
                    }
                });
        }

        function bootstrap() {
            initApiConfig();
            initStreetOptions();
            initPositionSelect();
            initDeckAndSlots();
            initButtons();
            initNumericInputs();
            initRiskSlider();
            initOpponentControls();
            initLanguageToggle();
            translatePage();
            initHealthCheck();
        }
    </script>
</body>
</html>
