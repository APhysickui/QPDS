<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QPDS - Quantitative Poker Decision System</title>
    <style>
        :root {
            color-scheme: dark;
            --bg-primary: #2d2b55;
            --bg-secondary: #1e1b48;
            --bg-tertiary: #160f3d;
            --accent-purple: #b362ff;
            --accent-cyan: #64f4ff;
            --accent-pink: #ff7edb;
            --accent-gold: #f7c548;
            --text-primary: #f8f7ff;
            --text-secondary: #c7c7ff;
            --text-muted: #9da1ff;
            --panel-border: rgba(137, 97, 255, 0.45);
            --panel-bg: rgba(29, 26, 66, 0.85);
            --chip-shadow: 0 18px 35px rgba(99, 72, 199, 0.45);
            --card-shadow: 0 12px 28px rgba(22, 14, 46, 0.6);
            --font-sans: 'Inter', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            --font-code: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'Operator Mono', Menlo, Monaco, 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background: radial-gradient(circle at top left, rgba(100, 244, 255, 0.18), rgba(179, 98, 255, 0.05) 45%, transparent 70%),
                        linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 55%, var(--bg-tertiary) 100%);
            min-height: 100vh;
            padding: 32px 28px 56px;
            color: var(--text-primary);
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background:
                radial-gradient(circle at 20% 15%, rgba(100, 244, 255, 0.18), transparent 45%),
                radial-gradient(circle at 80% 10%, rgba(255, 126, 219, 0.2), transparent 55%),
                radial-gradient(circle at 50% 80%, rgba(179, 98, 255, 0.22), transparent 60%);
            opacity: 0.9;
            pointer-events: none;
            z-index: -2;
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background-image: linear-gradient(115deg, rgba(255, 255, 255, 0.04) 0, rgba(255, 255, 255, 0.02) 40%, rgba(255, 255, 255, 0.05) 100%);
            mix-blend-mode: soft-light;
            opacity: 0.35;
            pointer-events: none;
            z-index: -1;
        }

        .app {
            max-width: 1280px;
            margin: 0 auto 40px auto;
            position: relative;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
            position: relative;
            padding: 14px 22px 20px;
            border-radius: 22px;
            background: linear-gradient(140deg, rgba(25, 21, 56, 0.78), rgba(46, 38, 98, 0.42));
            border: 1px solid rgba(158, 118, 255, 0.42);
            box-shadow: 0 26px 52px rgba(18, 12, 43, 0.55);
            overflow: hidden;
        }

        .app-header::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 15% 15%, rgba(100, 244, 255, 0.25), transparent 60%),
                        radial-gradient(circle at 85% 20%, rgba(255, 126, 219, 0.25), transparent 60%);
            opacity: 0.55;
            pointer-events: none;
        }

        .header-buttons {
            display: flex;
            gap: 12px;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .header-art {
            position: absolute;
            inset: -40px -80px auto auto;
            width: 360px;
            height: 240px;
            pointer-events: none;
            display: flex;
            justify-content: flex-end;
            align-items: flex-start;
            gap: 18px;
            transform: rotate(-6deg);
            opacity: 0.75;
            flex-wrap: wrap;
        }

        .chip {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.32), rgba(179, 98, 255, 0.82));
            border: 6px double rgba(255, 255, 255, 0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 2.1rem;
            text-shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
            box-shadow: var(--chip-shadow);
            animation: chipFloat 6s ease-in-out infinite;
        }

        .chip-ace {
            width: 120px;
            height: 120px;
            font-size: 2.4rem;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.45), rgba(100, 244, 255, 0.82));
            animation-delay: 0.5s;
        }

        .chip-heart {
            background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.35), rgba(255, 126, 219, 0.78));
            border-width: 5px;
            animation-delay: 1.5s;
        }

        .chip-diamond {
            background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.32), rgba(247, 197, 72, 0.8));
            border-width: 4px;
            animation-delay: 2.3s;
        }

        .chip-club {
            background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.3), rgba(179, 98, 255, 0.75));
            border-width: 4px;
            animation-delay: 3.1s;
        }

        @keyframes chipFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-14px) rotate(4deg); }
        }

        .settings-btn,
        .lang-toggle {
            padding: 10px 20px;
            border: 1px solid rgba(179, 98, 255, 0.35);
            border-radius: 999px;
            background: rgba(179, 98, 255, 0.16);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            backdrop-filter: blur(6px);
        }

        .settings-btn:hover,
        .lang-toggle:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 28px rgba(15, 16, 48, 0.45);
            border-color: rgba(100, 244, 255, 0.45);
        }

        .api-status {
            font-size: 0.85rem;
            color: rgba(247, 249, 252, 0.92);
            background: rgba(100, 244, 255, 0.12);
            border-radius: 999px;
            padding: 6px 12px;
            border: 1px solid rgba(100, 244, 255, 0.32);
        }

        .title-block {
            position: relative;
            z-index: 1;
        }

        .title-block h1 {
            font-size: 2.7rem;
            font-weight: 700;
            letter-spacing: 0.06em;
            color: var(--accent-cyan);
            text-shadow: 0 10px 24px rgba(100, 244, 255, 0.28);
        }

        .title-block p {
            margin-top: 6px;
            font-size: 1.05rem;
            color: var(--text-muted);
            opacity: 0.9;
        }

        .layout {
            display: grid;
            grid-template-columns: minmax(320px, 0.95fr) minmax(0, 1.25fr);
            gap: 22px;
        }

        .panel {
            background: linear-gradient(165deg, rgba(30, 41, 59, 0.88), rgba(15, 23, 42, 0.96));
            backdrop-filter: blur(16px);
            border-radius: 22px;
            padding: 24px 26px;
            border: 1px solid rgba(148, 163, 184, 0.22);
            box-shadow: 0 26px 52px rgba(15, 23, 42, 0.5);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            inset: 1.5px;
            border-radius: 20px;
            border: 1px solid rgba(100, 244, 255, 0.08);
            pointer-events: none;
        }

        .panel::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top right, rgba(255, 126, 219, 0.14), transparent 60%),
                        radial-gradient(circle at bottom left, rgba(100, 244, 255, 0.12), transparent 55%);
            opacity: 0.35;
            pointer-events: none;
        }

        .panel h2 {
            font-size: 1.42rem;
            margin-bottom: 20px;
            color: #e0f2fe;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 0.04em;
        }

        .panel h2::before {
            content: '♠';
            font-size: 1.45rem;
            color: var(--accent-purple);
            text-shadow: 0 0 12px rgba(179, 98, 255, 0.6);
        }

        #lessonPanel > h2::before { content: '♣'; color: var(--accent-pink); }
        #statePanel > h2::before { content: '♠'; }
        #deckPanel > h2::before { content: '♦'; color: var(--accent-gold); }

        .lesson-list {
            display: grid;
            gap: 12px;
            margin-top: 16px;
        }

        .lesson-item {
            background: rgba(37, 33, 74, 0.55);
            border-radius: 14px;
            padding: 16px 18px;
            border-left: 4px solid rgba(179, 98, 255, 0.8);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .game-manual-btn {
            padding: 10px 20px;
            border: 1px solid rgba(255, 126, 219, 0.4);
            border-radius: 999px;
            background: rgba(255, 126, 219, 0.18);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            backdrop-filter: blur(6px);
        }

        .game-manual-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 18px 32px rgba(78, 15, 86, 0.45);
            border-color: rgba(255, 126, 219, 0.6);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
        }

        .modal-overlay.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #374785, #243B55);
            border-radius: 16px;
            padding: 30px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            margin: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            color: #f7f9fc;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 16px;
        }

        .modal-title {
            font-size: 2rem;
            font-weight: 700;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: #f7f9fc;
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .manual-section {
            margin-bottom: 24px;
        }

        .manual-section h3 {
            font-size: 1.3rem;
            margin-bottom: 12px;
            color: #8ec5fc;
        }

        .manual-section p, .manual-section li {
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .manual-section ul {
            padding-left: 20px;
        }

        .hand-rankings {
            display: grid;
            gap: 12px;
        }

        .hand-rank {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hand-rank-name {
            font-weight: 600;
        }

        .hand-rank-example {
            font-family: monospace;
            color: #8ec5fc;
        }

        .position-categories {
            margin: 16px 0;
        }

        .position-category {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            border-left: 4px solid #8ec5fc;
        }

        .position-category h4 {
            margin: 0 0 12px 0;
            color: #8ec5fc;
            font-size: 1.1rem;
        }

        .position-category ul {
            margin: 0;
            padding-left: 20px;
        }

        .position-category li {
            margin-bottom: 8px;
        }

        .position-tips {
            background: rgba(142, 197, 252, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-top: 20px;
        }

        .position-tips h4 {
            margin: 0 0 12px 0;
            color: #8ec5fc;
        }

        .position-tips ul {
            margin: 0;
            padding-left: 20px;
        }

        .position-tips li {
            margin-bottom: 8px;
        }

        .beginner-tip {
            background: linear-gradient(135deg, rgba(142, 197, 252, 0.15), rgba(68, 189, 50, 0.1));
            border: 2px solid rgba(142, 197, 252, 0.3);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 24px;
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(142, 197, 252, 0.3); }
            to { box-shadow: 0 0 20px rgba(142, 197, 252, 0.6); }
        }

        .beginner-tip h3 {
            margin: 0 0 12px 0;
            color: #8ec5fc;
            font-size: 1.2rem;
        }

        .beginner-steps {
            margin: 12px 0;
            padding-left: 20px;
            line-height: 1.6;
        }

        .beginner-steps li {
            margin-bottom: 8px;
            color: #f0f4ff;
        }

        .dismiss-tip {
            background: rgba(142, 197, 252, 0.2);
            border: 1px solid rgba(142, 197, 252, 0.4);
            color: #f0f4ff;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 12px;
            transition: all 0.2s ease;
        }

        .dismiss-tip:hover {
            background: rgba(142, 197, 252, 0.3);
            transform: translateY(-1px);
        }

        .beginner-tip.hidden {
            display: none;
        }

        .hand-categories {
            margin: 16px 0;
        }

        .hand-category {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .hand-category.premium {
            border-left: 4px solid #4CAF50;
        }

        .hand-category.strong {
            border-left: 4px solid #FF9800;
        }

        .hand-category.speculative {
            border-left: 4px solid #2196F3;
        }

        .hand-category h4 {
            margin: 0 0 12px 0;
            font-size: 1rem;
        }

        .hand-examples {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .hand-example {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: monospace;
            font-weight: 600;
            font-size: 0.9rem;
            color: #8ec5fc;
        }

        .hand-tips {
            background: rgba(142, 197, 252, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
        }

        .hand-tips p {
            margin: 0;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .lesson-item strong {
            display: block;
            font-size: 0.95rem;
            margin-bottom: 6px;
        }

        .lesson-item span {
            font-size: 0.92rem;
            opacity: 0.9;
            line-height: 1.5;
        }

        .cheatsheet {
            margin-top: 22px;
            padding: 18px 20px;
            border-radius: 18px;
            background: rgba(25, 23, 60, 0.65);
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        }

        .cheatsheet h3 {
            font-size: 1.02rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-secondary);
            margin-bottom: 16px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .cheatsheet h3::before {
            content: '♣';
            font-size: 1.2rem;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px rgba(100, 244, 255, 0.55);
        }

        .cheatsheet-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 18px;
        }

        .cheatsheet-card {
            background: rgba(20, 18, 48, 0.72);
            border-radius: 14px;
            padding: 16px;
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        }

        .cheatsheet-label {
            font-size: 0.9rem;
            color: var(--accent-purple);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 10px;
        }

        .cheatsheet-card ul {
            margin: 0;
            padding-left: 18px;
            display: grid;
            gap: 8px;
        }

        .cheatsheet-card li {
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.45;
        }

        .section {
            margin-bottom: 18px;
        }

        .section h3 {
            font-size: 1.08rem;
            margin-bottom: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .section h3::before {
            content: '♦';
            font-size: 1.2rem;
            color: var(--accent-pink);
            text-shadow: 0 0 10px rgba(255, 126, 219, 0.55);
        }

        .stage-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 10px;
            margin-bottom: 18px;
        }

        .stage-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(29, 27, 68, 0.6);
            border-radius: 12px;
            padding: 10px 14px;
            cursor: pointer;
            transition: background 0.2s ease, border 0.2s ease;
            font-size: 0.92rem;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .stage-options label:hover {
            border-color: rgba(100, 244, 255, 0.35);
        }

        .stage-options input[type="radio"] {
            accent-color: var(--accent-purple);
        }

        .stage-options label.active {
            background: linear-gradient(140deg, rgba(179, 98, 255, 0.28), rgba(100, 244, 255, 0.22));
            border: 1px solid rgba(100, 244, 255, 0.45);
        }

        .card-slots {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(78px, 1fr));
            gap: 12px;
        }

        .card-slot {
            position: relative;
            border-radius: 16px;
            min-height: 110px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.45rem;
            color: rgba(255, 255, 255, 0.68);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease;
            background: linear-gradient(155deg, rgba(45, 43, 85, 0.65), rgba(24, 18, 52, 0.85));
            border: 1px solid rgba(148, 163, 184, 0.22);
            box-shadow: var(--card-shadow);
        }

        .card-slot[data-disabled="true"] {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .card-slot[data-selected="true"] {
            border-color: rgba(100, 244, 255, 0.65);
            background: linear-gradient(160deg, rgba(100, 244, 255, 0.18), rgba(94, 53, 156, 0.55));
            transform: translateY(-4px);
            box-shadow: 0 18px 32px rgba(21, 13, 52, 0.55);
        }

        .card-slot .card-label {
            position: absolute;
            top: 6px;
            left: 8px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: rgba(255, 255, 255, 0.55);
        }

        .card-slot .remove-tag {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(179, 98, 255, 0.22);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.85);
        }

        .card-slot[data-filled="true"] {
            border-color: rgba(255, 126, 219, 0.45);
            background: linear-gradient(160deg, rgba(255, 241, 255, 0.14), rgba(122, 87, 244, 0.45));
            color: #fff;
            font-weight: 600;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
        }

        .card-slot[data-filled="true"] .remove-tag {
            cursor: pointer;
        }

        .inputs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
        }

        label.field-label {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.85rem;
            opacity: 0.85;
            letter-spacing: 0.04em;
        }

        input[type="number"],
        input[type="text"],
        select {
            background: rgba(31, 28, 66, 0.75);
            border: 1px solid rgba(148, 163, 184, 0.28);
            border-radius: 12px;
            padding: 11px 14px;
            color: var(--text-primary);
            font-size: 0.96rem;
            font-family: var(--font-code);
            letter-spacing: 0.01em;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        input::placeholder,
        select option {
            color: rgba(255, 255, 255, 0.6);
        }

        select {
            cursor: pointer;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            border-color: rgba(100, 244, 255, 0.55);
            box-shadow: 0 0 0 3px rgba(100, 244, 255, 0.2);
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-top: 10px;
        }

        .slider-row span {
            font-size: 0.82rem;
            opacity: 0.75;
        }

        .slider-row strong {
            font-size: 0.95rem;
            color: #f1f5ff;
        }

        input[type="range"] {
            flex: 1;
            accent-color: var(--accent-purple);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 20px;
        }

        .button-group button {
            flex: 1 1 180px;
            padding: 12px 16px;
            border: 1px solid rgba(179, 98, 255, 0.35);
            border-radius: 14px;
            font-size: 0.96rem;
            font-weight: 600;
            cursor: pointer;
            color: var(--text-primary);
            background: linear-gradient(135deg, rgba(179, 98, 255, 0.38), rgba(100, 244, 255, 0.2));
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            backdrop-filter: blur(6px);
        }

        .button-group button:hover {
            transform: translateY(-3px);
            box-shadow: 0 18px 36px rgba(21, 17, 56, 0.55);
            border-color: rgba(100, 244, 255, 0.45);
        }

        .button-group .ghost {
            background: rgba(37, 33, 74, 0.55);
            color: var(--text-muted);
            border-color: rgba(148, 163, 184, 0.25);
        }

        .deck-panel {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .deck-grid {
            display: grid;
            gap: 10px;
            padding: 12px 14px;
            background: rgba(21, 19, 48, 0.6);
            border-radius: 18px;
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            overflow-x: auto;
        }

        .deck-row {
            display: grid;
            grid-template-columns: 48px repeat(13, minmax(44px, 1fr));
            gap: 8px;
            align-items: center;
            padding: 6px 0;
        }

        .deck-suit {
            justify-self: center;
            font-size: 1.4rem;
            color: var(--accent-cyan);
            text-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
            opacity: 0.9;
        }

        .deck-row[data-suit="hearts"] .deck-suit { color: #ff7d9c; }
        .deck-row[data-suit="diamonds"] .deck-suit { color: var(--accent-gold); }
        .deck-row[data-suit="clubs"] .deck-suit { color: var(--accent-purple); }

        .card-button {
            border: 1px solid rgba(148, 163, 184, 0.22);
            border-radius: 10px;
            padding: 10px 6px;
            font-size: 0.96rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease, border-color 0.15s ease;
            background: linear-gradient(150deg, rgba(45, 43, 85, 0.9), rgba(28, 20, 58, 0.85));
            color: var(--text-primary);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            font-family: var(--font-code);
            justify-self: center;
        }

        .card-button[data-suit="hearts"],
        .card-button[data-suit="diamonds"] {
            color: #ff7d9c;
        }

        .card-button[data-suit="spades"],
        .card-button[data-suit="clubs"] {
            color: #64f4ff;
        }

        .card-button:hover {
            transform: translateY(-3px);
            border-color: rgba(100, 244, 255, 0.35);
            box-shadow: 0 15px 26px rgba(19, 12, 44, 0.45);
        }

        .card-button[data-used="true"] {
            filter: saturate(0.3) brightness(0.7);
            opacity: 0.4;
            cursor: not-allowed;
        }

        .analysis-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .result-banner {
            background: linear-gradient(135deg, rgba(45, 43, 85, 0.9), rgba(24, 18, 52, 0.85));
            border-radius: 18px;
            padding: 22px;
            text-align: center;
            color: var(--text-primary);
            border: 1px solid rgba(100, 244, 255, 0.28);
            box-shadow: 0 24px 48px rgba(12, 9, 32, 0.55);
        }

        .result-banner .action-label {
            font-size: 0.9rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .result-banner .action-value {
            font-size: 2rem;
            font-weight: 700;
            margin-top: 8px;
            text-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        }

        .result-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 12px;
            text-align: left;
        }

        .result-detail {
            background: rgba(37, 33, 74, 0.65);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(148, 163, 184, 0.18);
        }

        .result-detail span {
            display: block;
            font-size: 0.78rem;
            letter-spacing: 0.08em;
            opacity: 0.68;
            text-transform: uppercase;
        }

        .result-detail strong {
            display: block;
            margin-top: 4px;
            font-size: 1.05rem;
            color: var(--accent-cyan);
        }

        .explanation-box {
            background: rgba(32, 30, 70, 0.72);
            border-radius: 14px;
            padding: 16px;
            font-size: 0.94rem;
            line-height: 1.6;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            color: var(--text-secondary);
        }

        .factors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
        }

        .factor-card {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 14px;
            padding: 16px;
            border: 1px solid rgba(148, 163, 184, 0.14);
            box-shadow: inset 0 0 0 1px rgba(34, 211, 238, 0.04);
        }

        .factor-card .factor-name {
            font-size: 0.75rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            opacity: 0.68;
        }

        .factor-card .factor-value {
            font-size: 1.2rem;
            font-weight: 600;
            margin-top: 6px;
            color: #e0f2fe;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 14px;
            margin-top: 18px;
        }

        .summary-item {
            background: rgba(15, 23, 42, 0.58);
            border-radius: 12px;
            padding: 14px;
            border: 1px solid rgba(148, 163, 184, 0.12);
        }

        .summary-item span {
            display: block;
            font-size: 0.78rem;
            letter-spacing: 0.08em;
            opacity: 0.7;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .summary-item strong {
            display: block;
            margin-top: 4px;
            font-size: 1.05rem;
            color: var(--accent-cyan);
        }

        .opponent-section {
            margin-top: 28px;
            padding: 20px;
            border-radius: 18px;
            background: rgba(30, 41, 59, 0.75);
            border: 1px solid rgba(148, 163, 184, 0.18);
        }

        .opponent-section h3 {
            margin-bottom: 16px;
            font-size: 1.1rem;
            color: #bae6fd;
        }

        .opponent-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
        }

        .metric-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(15, 23, 42, 0.65);
            border: 1px solid rgba(148, 163, 184, 0.12);
        }

        .metric-group span {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .metric-group input[type="range"] {
            width: 100%;
        }

        .metric-group input[type="number"],
        .metric-group select,
        .metric-group textarea {
            width: 100%;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            resize: vertical;
        }

        .metric-group textarea {
            min-height: 64px;
        }

        .metric-range-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .insights-panel {
            margin-top: 24px;
            padding: 20px;
            border-radius: 18px;
            background: rgba(15, 76, 129, 0.18);
            border: 1px solid rgba(56, 189, 248, 0.25);
        }

        .insights-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 16px;
        }

        .archetype-pill {
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(56, 189, 248, 0.2);
            color: #bae6fd;
            font-weight: 600;
            font-size: 0.88rem;
        }

        .insight-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 14px;
        }

        .insight-card {
            padding: 14px;
            border-radius: 14px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.16);
        }

        .insight-card strong {
            display: block;
            margin-bottom: 6px;
            color: #e0f2fe;
        }

        .insight-notes {
            margin-top: 16px;
            display: grid;
            gap: 8px;
        }

        .insight-note {
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(30, 58, 138, 0.25);
            border: 1px solid rgba(59, 130, 246, 0.28);
            font-size: 0.88rem;
            line-height: 1.4;
        }

        .loading {
            display: none;
            justify-content: center;
            align-items: center;
            gap: 12px;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .loading.active {
            display: flex;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.15);
            border-top: 4px solid #8ec5fc;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-box {
            background: linear-gradient(135deg, rgba(214, 69, 65, 0.22), rgba(122, 38, 69, 0.28));
            border: 1px solid rgba(214, 69, 65, 0.45);
            border-radius: 14px;
            padding: 14px 16px;
            font-size: 0.9rem;
            line-height: 1.5;
            display: none;
            color: #ffeaf1;
            box-shadow: 0 18px 32px rgba(78, 15, 29, 0.35);
        }

        .error-box.active {
            display: block;
        }

        @media (max-width: 1024px) {
            .layout {
                grid-template-columns: 1fr;
            }

            .deck-panel {
                order: 3;
            }
        }

        @media (max-width: 640px) {
            body {
                padding: 16px;
            }

            .app-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .header-art {
                display: none;
            }

            .button-group button {
                flex: 1 1 100%;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <div class="title-block">
                <h1 data-i18n="title">QPDS</h1>
                <p data-i18n="subtitle">量化德州扑克决策辅助系统</p>
            </div>
            <div class="header-buttons">
                <button class="game-manual-btn" id="gameManualBtn" data-i18n="buttons.gameManual">🃏 游戏手册</button>
                <button id="apiConfigBtn" class="settings-btn" data-i18n="buttons.apiConfig">⚙️ API</button>
                <button id="langToggle" class="lang-toggle">English</button>
                <span class="api-status" id="apiStatusLabel"></span>
            </div>
            <div class="header-art" aria-hidden="true">
                <div class="chip chip-ace">A♠</div>
                <div class="chip chip-heart">♥</div>
                <div class="chip chip-diamond">♦</div>
                <div class="chip chip-club">♣</div>
            </div>
        </header>

        <div class="layout">
            <section class="panel" id="lessonPanel">
                <h2 data-i18n="lesson.heading">无限注德州扑克：规则速览</h2>

                <div class="beginner-tip" id="beginnerTip">
                    <h3 data-i18n="beginner.title">🚀 新手快速入门</h3>
                    <div class="tip-content">
                        <p data-i18n="beginner.intro">第一次使用？按以下步骤开始：</p>
                        <ol class="beginner-steps">
                            <li data-i18n="beginner.step1">选择底牌：点击左边"你的底牌"区域的空槽，然后从下方牌堆选择两张牌</li>
                            <li data-i18n="beginner.step2">设置阶段：选择当前游戏阶段（建议新手从"翻前"开始）</li>
                            <li data-i18n="beginner.step3">输入参数：设置底池100、跟注20、双方筹码各500</li>
                            <li data-i18n="beginner.step4">选择位置：如不确定选择"按钮位(BTN)"</li>
                            <li data-i18n="beginner.step5">获取建议：点击"获取决策建议"查看推荐行动</li>
                        </ol>
                        <button class="dismiss-tip" id="dismissTip" data-i18n="beginner.dismiss">我知道了</button>
                    </div>
                </div>

                <div class="lesson-list">
                    <div class="lesson-item">
                        <strong data-i18n="lesson.goal.title">核心目标</strong>
                        <span data-i18n="lesson.goal.copy">通过摊牌赢得最大成手牌，或让所有对手弃牌，夺取底池。</span>
                    </div>
                    <div class="lesson-item">
                        <strong data-i18n="lesson.structure.title">一局流程</strong>
                        <span data-i18n="lesson.structure.copy">两张底牌起手，盲注做底，公共牌依次翻牌圈、转牌圈、河牌圈亮出，最多四轮下注。</span>
                    </div>
                    <div class="lesson-item">
                        <strong data-i18n="lesson.position.title">位置与信息</strong>
                        <span data-i18n="lesson.position.copy">按钮位最后行动优势最大，盲注位置翻牌后需率先行动。</span>
                    </div>
                    <div class="lesson-item">
                        <strong data-i18n="lesson.strategy.title">量化思维</strong>
                        <span data-i18n="lesson.strategy.copy">胜率、底池赔率、风险偏好共同驱动决策，保持纪律，避免情绪化。</span>
                    </div>
                </div>

                <div class="cheatsheet">
                    <h3 data-i18n="lesson.cheatsheet.title">牌桌速查宝典</h3>
                    <div class="cheatsheet-grid">
                        <div class="cheatsheet-card">
                            <div class="cheatsheet-label" data-i18n="lesson.cheatsheet.preflop">翻前口令</div>
                            <ul>
                                <li data-i18n="lesson.cheatsheet.preflop1">按钮位 3x 开局，宽松偷盲</li>
                                <li data-i18n="lesson.cheatsheet.preflop2">前位紧凶：顶级对子 + 强同花连牌</li>
                                <li data-i18n="lesson.cheatsheet.preflop3">大盲防守：赔率 ≥ 3:1 才跟注</li>
                            </ul>
                        </div>
                        <div class="cheatsheet-card">
                            <div class="cheatsheet-label" data-i18n="lesson.cheatsheet.flop">翻牌读牌</div>
                            <ul>
                                <li data-i18n="lesson.cheatsheet.flop1">干燥板：中等对子可持续下注</li>
                                <li data-i18n="lesson.cheatsheet.flop2">湿润板：优先保护，减小下注尺度</li>
                                <li data-i18n="lesson.cheatsheet.flop3">中顺/同花听牌：计算补牌 ×4 概率</li>
                            </ul>
                        </div>
                        <div class="cheatsheet-card">
                            <div class="cheatsheet-label" data-i18n="lesson.cheatsheet.turn">转牌决策</div>
                            <ul>
                                <li data-i18n="lesson.cheatsheet.turn1">SPR &lt; 1.5：牌力够强可直接投入</li>
                                <li data-i18n="lesson.cheatsheet.turn2">对手加注 => 评估范围优势是否反转</li>
                                <li data-i18n="lesson.cheatsheet.turn3">半诈唬需保证弃牌率 × 底池 ≥ 成本</li>
                            </ul>
                        </div>
                        <div class="cheatsheet-card">
                            <div class="cheatsheet-label" data-i18n="lesson.cheatsheet.river">河牌执行</div>
                            <ul>
                                <li data-i18n="lesson.cheatsheet.river1">价值下注：能被更差的牌跟注？</li>
                                <li data-i18n="lesson.cheatsheet.river2">精准诈唬：代表强牌 + 阻断对手关键牌</li>
                                <li data-i18n="lesson.cheatsheet.river3">错过听牌 → 权衡弃牌率 / 摊牌价值</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <section class="panel" id="statePanel">
                <div class="section">
                    <h2 data-i18n="state.heading">牌局设置</h2>
                    <div class="stage-options" id="streetOptions">
                        <label data-street="PREFLOP" class="active">
                            <input type="radio" name="street" value="PREFLOP" checked>
                            <span data-i18n="streets.PREFLOP">翻前 (Preflop)</span>
                        </label>
                        <label data-street="FLOP">
                            <input type="radio" name="street" value="FLOP">
                            <span data-i18n="streets.FLOP">翻牌圈 (Flop)</span>
                        </label>
                        <label data-street="TURN">
                            <input type="radio" name="street" value="TURN">
                            <span data-i18n="streets.TURN">转牌圈 (Turn)</span>
                        </label>
                        <label data-street="RIVER">
                            <input type="radio" name="street" value="RIVER">
                            <span data-i18n="streets.RIVER">河牌圈 (River)</span>
                        </label>
                    </div>
                </div>

                <div class="section">
                    <h3 data-i18n="state.hero">你的底牌</h3>
                    <div class="card-slots" id="heroSlots"></div>
                </div>

                <div class="section">
                    <h3 data-i18n="state.board">公共牌</h3>
                    <div class="card-slots" id="boardSlots"></div>
                </div>

                <div class="section">
                    <h3 data-i18n="state.parameters">筹码与参数</h3>
                    <div class="inputs-grid">
                        <label class="field-label">
                            <span data-i18n="fields.pot">底池大小</span>
                            <input type="number" id="potInput" min="0" step="0.01" value="100" data-i18n-placeholder="placeholders.pot">
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.toCall">需要跟注</span>
                            <input type="number" id="toCallInput" min="0" step="0.01" value="10" data-i18n-placeholder="placeholders.toCall">
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.heroStack">你的筹码</span>
                            <input type="number" id="heroStackInput" min="0" step="0.01" value="500" data-i18n-placeholder="placeholders.heroStack">
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.villainStack">对手筹码</span>
                            <input type="number" id="villainStackInput" min="0" step="0.01" value="500" data-i18n-placeholder="placeholders.villainStack">
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.position">你的位置</span>
                            <select id="positionSelect"></select>
                        </label>
                        <label class="field-label">
                            <span data-i18n="fields.villainRange">对手范围</span>
                            <input type="text" id="rangeInput" data-i18n-placeholder="placeholders.villainRange" placeholder="AA,KK,QQ,AKs">
                        </label>
                    </div>

                    <div class="slider-row">
                        <span data-i18n="risk.conservative">保守</span>
                        <input type="range" id="riskSlider" min="0" max="10" value="5">
                        <span data-i18n="risk.aggressive">激进</span>
                        <strong id="riskValue">5</strong>
                    </div>
                </div>

                <div class="opponent-section" id="opponentSection">
                    <h3 data-i18n="opponent.heading">对手建模</h3>
                    <div class="opponent-grid">
                        <div class="metric-group">
                            <span data-i18n="opponent.aggression.label">激进程度</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.aggression.low">被动</small>
                                <small id="opAggressionValue">6/10</small>
                                <small data-i18n="opponent.aggression.high">激进</small>
                            </div>
                            <input type="range" id="opAggressionInput" min="0" max="10" value="6">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.tightness.label">起手范围</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.tightness.wide">宽松</small>
                                <small id="opTightnessValue">5/10</small>
                                <small data-i18n="opponent.tightness.narrow">紧实</small>
                            </div>
                            <input type="range" id="opTightnessInput" min="0" max="10" value="5">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.bluff.label">诈唬频率</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.bluff.low">罕见</small>
                                <small id="opBluffValue">3/10</small>
                                <small data-i18n="opponent.bluff.high">频繁</small>
                            </div>
                            <input type="range" id="opBluffInput" min="0" max="10" value="3">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.confidence.label">对手自信</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.confidence.low">犹豫</small>
                                <small id="opConfidenceValue">6/10</small>
                                <small data-i18n="opponent.confidence.high">自信</small>
                            </div>
                            <input type="range" id="opConfidenceInput" min="0" max="10" value="6">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.tilt.label">情绪波动</span>
                            <div class="metric-range-label">
                                <small data-i18n="opponent.tilt.calm">冷静</small>
                                <small id="opTiltValue">4/10</small>
                                <small data-i18n="opponent.tilt.hot">倾向失控</small>
                            </div>
                            <input type="range" id="opTiltInput" min="0" max="10" value="4">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.bet.label">最近下注占底池%</span>
                            <input type="number" id="opBetPctInput" min="0" max="400" step="1" value="65" data-i18n-placeholder="opponent.bet.placeholder" placeholder="例如 70">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.action.label">最近动作</span>
                            <select id="opActionStreet">
                                <option value="PREFLOP" data-i18n="streets.PREFLOP">翻前 (Preflop)</option>
                                <option value="FLOP" data-i18n="streets.FLOP">翻牌圈 (Flop)</option>
                                <option value="TURN" data-i18n="streets.TURN">转牌圈 (Turn)</option>
                                <option value="RIVER" data-i18n="streets.RIVER">河牌圈 (River)</option>
                            </select>
                            <select id="opActionType">
                                <option value="bet" data-i18n="opponent.action.bet">下注</option>
                                <option value="raise" data-i18n="opponent.action.raise">加注</option>
                                <option value="call" data-i18n="opponent.action.call">跟注</option>
                                <option value="check" data-i18n="opponent.action.check">过牌</option>
                            </select>
                            <input type="number" id="opActionAmount" min="0" step="0.01" data-i18n-placeholder="opponent.action.amount" placeholder="例如 80">
                            <input type="number" id="opActionPot" min="0" step="0.01" data-i18n-placeholder="opponent.action.pot" placeholder="行动前底池">
                        </div>
                        <div class="metric-group">
                            <span data-i18n="opponent.notes.label">额外备注</span>
                            <textarea id="opNotesInput" data-i18n-placeholder="opponent.notes.placeholder" placeholder="例如：翻牌圈持续下注，河牌紧凶"></textarea>
                        </div>
                    </div>
                </div>

                <div class="button-group">
                    <button id="recommendButton" data-i18n="buttons.recommend">获取决策建议</button>
                    <button id="equityButton" data-i18n="buttons.equity">仅计算胜率</button>
                    <button id="resetButton" class="ghost" data-i18n="buttons.reset">重置牌面</button>
                </div>

                <div class="error-box" id="errorBox"></div>
            </section>

            <section class="panel deck-panel" id="deckPanel">
                <div>
                    <h2 data-i18n="deck.heading">牌堆 (点击选择卡牌)</h2>
                    <p data-i18n="deck.hint" style="font-size:0.9rem;opacity:0.75;line-height:1.5;margin-top:6px;">
                        先点击空槽再点选卡牌；已选卡牌会自动灰化，点击槽位右上角可清除。
                    </p>
                </div>
                <div class="deck-grid" id="deckGrid"></div>
            </section>

            <section class="panel analysis-panel" id="analysisPanel">
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <span data-i18n="loading">正在为你量化牌局...</span>
                </div>

                <div class="result-banner" id="resultBanner" style="display: none;">
                    <div class="action-label" data-i18n="result.action">推荐行动</div>
                    <div class="action-value" id="actionValue">-</div>
                    <div class="result-details">
                        <div class="result-detail">
                            <span data-i18n="result.confidence">置信度</span>
                            <strong id="confidenceValue">-</strong>
                        </div>
                        <div class="result-detail">
                            <span data-i18n="result.ev">预期盈利</span>
                            <strong id="evValue">-</strong>
                        </div>
                    </div>
                </div>

                <div class="explanation-box" id="explanationBox" style="display: none;"></div>

                <div class="insights-panel" id="opponentInsights" style="display: none;">
                    <div class="insights-header">
                        <h3 data-i18n="opponent.insights.heading">对手画像</h3>
                        <span class="archetype-pill" id="opponentArchetype"></span>
                    </div>
                    <p id="opponentSummary" style="font-size:0.92rem;line-height:1.6;opacity:0.82;margin-bottom:16px;"></p>
                    <div class="insight-cards">
                        <div class="insight-card">
                            <strong data-i18n="opponent.insights.aggression">激进指数</strong>
                            <span id="opponentAggressionMetric">-</span>
                        </div>
                        <div class="insight-card">
                            <strong data-i18n="opponent.insights.betting">下注压力</strong>
                            <span id="opponentBettingMetric">-</span>
                        </div>
                        <div class="insight-card">
                            <strong data-i18n="opponent.insights.psychology">心理压强</strong>
                            <span id="opponentPsychologyMetric">-</span>
                        </div>
                        <div class="insight-card">
                            <strong data-i18n="opponent.insights.range">范围优势</strong>
                            <span id="opponentRangeMetric">-</span>
                        </div>
                    </div>
                    <div class="insight-notes" id="opponentNotes"></div>
                </div>

                <div>
                    <h3 data-i18n="summary.heading">当前输入概览</h3>
                    <div class="summary-grid" id="summaryGrid"></div>
                </div>

                <div>
                    <h3 data-i18n="factors.heading">关键因子</h3>
                    <div class="factors-grid" id="factorsGrid"></div>
                </div>
            </section>
        </div>
    </div>

    <!-- 游戏手册模态框 -->
    <div class="modal-overlay" id="gameManualModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" data-i18n="manual.title">德州扑克游戏手册</h2>
                <button class="modal-close" id="closeManualBtn">&times;</button>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.basicRules">基本规则</h3>
                <p data-i18n="manual.basicRulesText">德州扑克（Texas Hold'em）是一种流行的扑克变体，每位玩家发2张底牌，通过与5张公共牌结合组成最佳的5张牌型。</p>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.gameFlow">游戏流程</h3>
                <ul>
                    <li><strong data-i18n="manual.preflop">翻前（Pre-flop）</strong>：<span data-i18n="manual.preflopDesc">每位玩家获得2张底牌，根据牌力决定跟注、加注或弃牌</span></li>
                    <li><strong data-i18n="manual.flop">翻牌（Flop）</strong>：<span data-i18n="manual.flopDesc">发出前3张公共牌，进行新一轮下注</span></li>
                    <li><strong data-i18n="manual.turn">转牌（Turn）</strong>：<span data-i18n="manual.turnDesc">发出第4张公共牌，继续下注</span></li>
                    <li><strong data-i18n="manual.river">河牌（River）</strong>：<span data-i18n="manual.riverDesc">发出第5张公共牌，最后一轮下注</span></li>
                    <li><strong data-i18n="manual.showdown">摊牌（Showdown）</strong>：<span data-i18n="manual.showdownDesc">比较牌型大小，最大牌型获胜</span></li>
                </ul>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.handRankings">牌型排名（从大到小）</h3>
                <div class="hand-rankings">
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.royalFlush">皇家同花顺</span>
                        <span class="hand-rank-example">A♠ K♠ Q♠ J♠ 10♠</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.straightFlush">同花顺</span>
                        <span class="hand-rank-example">9♥ 8♥ 7♥ 6♥ 5♥</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.fourOfKind">四条</span>
                        <span class="hand-rank-example">K♣ K♦ K♥ K♠ 3♦</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.fullHouse">葫芦</span>
                        <span class="hand-rank-example">Q♠ Q♥ Q♦ 7♣ 7♠</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.flush">同花</span>
                        <span class="hand-rank-example">A♦ J♦ 9♦ 6♦ 2♦</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.straight">顺子</span>
                        <span class="hand-rank-example">10♠ 9♥ 8♦ 7♣ 6♠</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.threeOfKind">三条</span>
                        <span class="hand-rank-example">8♣ 8♦ 8♥ K♠ 4♦</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.twoPair">两对</span>
                        <span class="hand-rank-example">A♠ A♥ 5♣ 5♦ 9♠</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.onePair">一对</span>
                        <span class="hand-rank-example">J♦ J♠ 10♥ 8♣ 3♦</span>
                    </div>
                    <div class="hand-rank">
                        <span class="hand-rank-name" data-i18n="manual.highCard">高牌</span>
                        <span class="hand-rank-example">A♠ K♦ Q♥ 8♣ 5♠</span>
                    </div>
                </div>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.keyConcepts">关键概念</h3>
                <ul>
                    <li><strong data-i18n="manual.potOdds">底池赔率（Pot Odds）</strong>：<span data-i18n="manual.potOddsDesc">当前跟注所需筹码与底池大小的比例</span></li>
                    <li><strong data-i18n="manual.impliedOdds">隐含赔率（Implied Odds）</strong>：<span data-i18n="manual.impliedOddsDesc">考虑后续可能赢得筹码的赔率</span></li>
                    <li><strong data-i18n="manual.position">位置（Position）</strong>：<span data-i18n="manual.positionDesc">相对于庄家位置，后位置有信息优势</span></li>
                    <li><strong data-i18n="manual.spr">筹码-底池比（SPR）</strong>：<span data-i18n="manual.sprDesc">有效筹码除以底池大小</span></li>
                    <li><strong data-i18n="manual.draws">听牌（Draw）</strong>：<span data-i18n="manual.drawsDesc">需要特定牌才能成牌的牌型</span></li>
                </ul>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.positions">位置详解</h3>
                <p data-i18n="manual.positionsIntro">在德州扑克中，你相对于庄家按钮的位置决定了行动顺序，是影响策略的关键因素：</p>

                <div class="position-categories">
                    <div class="position-category">
                        <h4 data-i18n="manual.earlyPositions">前位（Early Position）- 最先行动</h4>
                        <ul>
                            <li><strong data-i18n="manual.utg">UTG（枪口位）</strong>：<span data-i18n="manual.utgDesc">翻前第一个行动，信息最少，需要最强的牌</span></li>
                            <li><strong data-i18n="manual.utg1">UTG+1</strong>：<span data-i18n="manual.utg1Desc">第二个行动位置，仍然需要较强手牌</span></li>
                            <li><strong data-i18n="manual.utg2">UTG+2</strong>：<span data-i18n="manual.utg2Desc">可以略微放宽手牌要求</span></li>
                        </ul>
                    </div>

                    <div class="position-category">
                        <h4 data-i18n="manual.middlePositions">中位（Middle Position）</h4>
                        <ul>
                            <li><strong data-i18n="manual.mp1">MP1（中间位1）</strong>：<span data-i18n="manual.mp1Desc">可以玩更多边际手牌</span></li>
                            <li><strong data-i18n="manual.mp2">MP2（中间位2）</strong>：<span data-i18n="manual.mp2Desc">位置开始变得有利</span></li>
                            <li><strong data-i18n="manual.mp3">MP3（中间位3）</strong>：<span data-i18n="manual.mp3Desc">接近晚位的优势</span></li>
                        </ul>
                    </div>

                    <div class="position-category">
                        <h4 data-i18n="manual.latePositions">后位（Late Position）- 信息优势</h4>
                        <ul>
                            <li><strong data-i18n="manual.lj">LJ（劫匪位）</strong>：<span data-i18n="manual.ljDesc">可以观察前面玩家行动后决策</span></li>
                            <li><strong data-i18n="manual.hj">HJ（劫持位）</strong>：<span data-i18n="manual.hjDesc">非常有利的位置，可以偷盲</span></li>
                            <li><strong data-i18n="manual.co">CO（截断位）</strong>：<span data-i18n="manual.coDesc">仅次于按钮位的优势位置</span></li>
                            <li><strong data-i18n="manual.btn">BTN（按钮位）</strong>：<span data-i18n="manual.btnDesc">翻后永远最后行动，最佳位置</span></li>
                        </ul>
                    </div>

                    <div class="position-category">
                        <h4 data-i18n="manual.blindPositions">盲注位（Blind Positions）</h4>
                        <ul>
                            <li><strong data-i18n="manual.sb">SB（小盲位）</strong>：<span data-i18n="manual.sbDesc">翻后第一个行动，位置最差但已投入一半大盲</span></li>
                            <li><strong data-i18n="manual.bb">BB（大盲位）</strong>：<span data-i18n="manual.bbDesc">翻前最后行动，翻后第二个行动</span></li>
                        </ul>
                    </div>
                </div>

                <div class="position-tips">
                    <h4 data-i18n="manual.positionStrategy">位置策略要点</h4>
                    <ul>
                        <li data-i18n="manual.tip1">前位需要更强的起手牌，因为后面还有很多玩家要行动</li>
                        <li data-i18n="manual.tip2">后位可以玩更多投机性手牌，观察对手行动后再决策</li>
                        <li data-i18n="manual.tip3">按钮位是最有利位置，可以用更宽的范围加注和偷盲</li>
                        <li data-i18n="manual.tip4">盲注位置翻后不利，但翻前已有投入要考虑底池赔率</li>
                    </ul>
                </div>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.strategies">常用策略概念</h3>
                <ul>
                    <li><strong data-i18n="manual.tag">紧凶（TAG）</strong>：<span data-i18n="manual.tagDesc">只玩强牌但玩得激进</span></li>
                    <li><strong data-i18n="manual.lag">松凶（LAG）</strong>：<span data-i18n="manual.lagDesc">玩较多牌型且激进下注</span></li>
                    <li><strong data-i18n="manual.valueBet">价值下注</strong>：<span data-i18n="manual.valueBetDesc">有强牌时下注获取价值</span></li>
                    <li><strong data-i18n="manual.bluff">诈唬（Bluff）</strong>：<span data-i18n="manual.bluffDesc">用弱牌下注迫使对手弃牌</span></li>
                    <li><strong data-i18n="manual.semiBluff">半诈唬</strong>：<span data-i18n="manual.semiBluffDesc">用听牌下注，既可能成牌也可能让对手弃牌</span></li>
                </ul>
            </div>

            <div class="manual-section">
                <h3 data-i18n="manual.startingHands">新手起手牌建议</h3>
                <p data-i18n="manual.startingHandsIntro">作为新手，建议只玩以下强牌，避免复杂决策：</p>

                <div class="hand-categories">
                    <div class="hand-category premium">
                        <h4 data-i18n="manual.premiumHands">顶级强牌（任何位置都可以玩）</h4>
                        <div class="hand-examples">
                            <span class="hand-example">AA</span>
                            <span class="hand-example">KK</span>
                            <span class="hand-example">QQ</span>
                            <span class="hand-example">AKs</span>
                            <span class="hand-example">AKo</span>
                        </div>
                    </div>

                    <div class="hand-category strong">
                        <h4 data-i18n="manual.strongHands">强牌（中后位可以玩）</h4>
                        <div class="hand-examples">
                            <span class="hand-example">JJ</span>
                            <span class="hand-example">TT</span>
                            <span class="hand-example">99</span>
                            <span class="hand-example">AQs</span>
                            <span class="hand-example">AQo</span>
                            <span class="hand-example">AJs</span>
                            <span class="hand-example">KQs</span>
                        </div>
                    </div>

                    <div class="hand-category speculative">
                        <h4 data-i18n="manual.speculativeHands">投机牌（仅后位考虑）</h4>
                        <div class="hand-examples">
                            <span class="hand-example">88-22</span>
                            <span class="hand-example">ATs</span>
                            <span class="hand-example">A9s-A2s</span>
                            <span class="hand-example">KJs</span>
                            <span class="hand-example">QJs</span>
                            <span class="hand-example">JTs</span>
                        </div>
                    </div>
                </div>

                <div class="hand-tips">
                    <p data-i18n="manual.handTips">💡 "s"表示同花色，"o"表示不同花色。新手建议：前位只玩顶级强牌，后位可以适当放宽。</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_STORAGE_KEY = 'qpds.apiBaseUrl';
        const API_QUERY_PARAM = 'api';
        const LOCAL_API_URL = 'http://localhost:8080';
        const GITHUB_DEFAULT_API_URL = 'https://qpds-backend.onrender.com';

        function sanitizeApiUrl(url) {
            if (!url) {
                return null;
            }
            try {
                const parsed = new URL(url);
                if (!['http:', 'https:'].includes(parsed.protocol)) {
                    return null;
                }
                return parsed.origin;
            } catch (error) {
                return null;
            }
        }

        function resolveDefaultApiUrl() {
            if (window.location.hostname.endsWith('github.io')) {
                return GITHUB_DEFAULT_API_URL;
            }
            const override = sanitizeApiUrl(window.API_BASE_URL);
            if (override) {
                return override;
            }
            return LOCAL_API_URL;
        }

        function resolveApiUrl({ skipQuery = false } = {}) {
            if (!skipQuery) {
                const params = new URLSearchParams(window.location.search);
                const fromQuery = sanitizeApiUrl(params.get(API_QUERY_PARAM));
                if (fromQuery) {
                    params.delete(API_QUERY_PARAM);
                    const nextQuery = params.toString();
                    const nextUrl = `${window.location.pathname}${nextQuery ? `?${nextQuery}` : ''}${window.location.hash}`;
                    window.history.replaceState({}, '', nextUrl);
                    localStorage.setItem(API_STORAGE_KEY, fromQuery);
                    return fromQuery;
                }
            }

            const stored = sanitizeApiUrl(localStorage.getItem(API_STORAGE_KEY));
            if (stored) {
                return stored;
            }

            return resolveDefaultApiUrl();
        }

        let API_URL = resolveApiUrl();

        let deckGrid;
        let heroSlots;
        let boardSlots;
        let streetOptions;
        let positionSelect;
        let riskSlider;
        let riskValue;
        let langToggle;
        let apiConfigBtn;
        let apiStatusLabel;
        let loadingIndicator;
        let actionValue;
        let confidenceValue;
        let evValue;
        let resultBanner;
        let explanationBox;
        let factorsGrid;
        let errorBox;
        let summaryGrid;
        let opponentInsightsPanel;
        let opponentArchetype;
        let opponentSummary;
        let opponentNotesContainer;
        let opponentAggressionMetric;
        let opponentBettingMetric;
        let opponentPsychologyMetric;
        let opponentRangeMetric;
        let opAggressionInput;
        let opTightnessInput;
        let opBluffInput;
        let opConfidenceInput;
        let opTiltInput;
        let opBetPctInput;
        let opActionStreet;
        let opActionType;
        let opActionAmount;
        let opActionPot;
        let opNotesInput;
        let opAggressionValue;
        let opTightnessValue;
        let opBluffValue;
        let opConfidenceValue;
        let opTiltValue;

        const translations = {
            en: {
                title: 'QPDS',
                subtitle: 'Quantitative Poker Decision System',
                beginner: {
                    title: '🚀 Quick Start Guide',
                    intro: 'First time using? Follow these steps:',
                    step1: 'Select hole cards: Click empty slots under "Your Hole Cards", then choose two cards from deck below',
                    step2: 'Set stage: Choose current game stage (beginners should start with "Preflop")',
                    step3: 'Input parameters: Set pot 100, to call 20, both stacks 500',
                    step4: 'Choose position: If unsure, select "Button (BTN)"',
                    step5: 'Get recommendation: Click "Get Recommendation" to see suggested action',
                    dismiss: 'Got it!'
                },
                lesson: {
                    heading: 'No-Limit Texas Hold\'em Essentials',
                    goal: {
                        title: 'The Goal',
                        copy: 'Win chips either by showing the strongest five-card hand at showdown or by making everyone else fold.'
                    },
                    structure: {
                        title: 'Hand Structure',
                        copy: 'Two private cards per player, blinds create the pot, and up to four betting rounds across flop, turn, and river community cards.'
                    },
                    position: {
                        title: 'Position & Information',
                        copy: 'Button acts last post-flop and has the most information; blinds must act first on later streets.'
                    },
                    strategy: {
                        title: 'Quant Thinking',
                        copy: 'Equity, pot odds, and your risk slider drive disciplined, data-backed decisions.'
                    },
                    cheatsheet: {
                        title: 'Quick Ringside Cheatsheet',
                        preflop: 'Preflop Riff',
                        preflop1: 'Button: open 3x with wider range, steal blinds aggressively.',
                        preflop2: 'Early position: premium pairs + strong suited connectors only.',
                        preflop3: 'Big blind defense: call only if pot odds ≥ 3:1.',
                        flop: 'Flop Reading',
                        flop1: 'Dry boards: continue betting with middle pairs to deny equity.',
                        flop2: 'Wet boards: protect your made hands, size down to control pot.',
                        flop3: 'Strong draws: count outs ×4 to estimate hit probability.',
                        turn: 'Turn Decisions',
                        turn1: 'SPR < 1.5: strong hands can commit stacks.',
                        turn2: 'Facing raises: reassess range advantage before stacking off.',
                        turn3: 'Semi-bluff only if fold equity × pot ≥ risked chips.',
                        river: 'River Execution',
                        river1: 'Value bets: only if worse hands can call you.',
                        river2: 'Bluffs: tell a coherent story and block villain’s top combos.',
                        river3: 'Missed draws: balance fold equity vs showdown value.'
                    }
                },
                state: {
                    heading: 'Game State',
                    hero: 'Your Hole Cards',
                    board: 'Community Cards',
                    parameters: 'Stacks & Inputs'
                },
                streets: {
                    PREFLOP: 'Preflop',
                    FLOP: 'Flop',
                    TURN: 'Turn',
                    RIVER: 'River'
                },
                fields: {
                    pot: 'Pot Size',
                    toCall: 'Bet to Call',
                    heroStack: 'Your Stack',
                    villainStack: 'Villain Stack',
                    position: 'Your Position',
                    villainRange: 'Villain Range'
                },
                summary: {
                    heading: 'Current Inputs',
                    items: {
                        pot: 'Pot Size',
                        toCall: 'Bet to Call',
                        heroStack: 'Your Stack',
                        villainStack: 'Villain Stack',
                        street: 'Street',
                        position: 'Position',
                        risk: 'Risk Preference',
                        opponentModel: 'Opponent Read'
                    }
                },
                placeholders: {
                    pot: 'e.g. 100',
                    toCall: 'e.g. 20',
                    heroStack: 'e.g. 500',
                    villainStack: 'e.g. 500',
                    villainRange: 'AA,KK,QQ,AKs'
                },
                risk: {
                    conservative: 'Conservative',
                    aggressive: 'Aggressive'
                },
                buttons: {
                    recommend: 'Get Recommendation',
                    equity: 'Equity Only',
                    reset: 'Reset Cards',
                    gameManual: '🃏 Game Manual',
                    apiConfig: '⚙️ API'
                },
                opponent: {
                    heading: 'Opponent Model',
                    aggression: {
                        label: 'Aggression',
                        low: 'Passive',
                        high: 'Hyper aggressive'
                    },
                    tightness: {
                        label: 'Opening Range',
                        wide: 'Loose',
                        narrow: 'Tight'
                    },
                    bluff: {
                        label: 'Bluff Frequency',
                        low: 'Rare',
                        high: 'Frequent'
                    },
                    confidence: {
                        label: 'Table Confidence',
                        low: 'Hesitant',
                        high: 'Confident'
                    },
                    tilt: {
                        label: 'Emotional Tilt',
                        calm: 'Composed',
                        hot: 'Near tilt'
                    },
                    bet: {
                        label: 'Latest bet % of pot',
                        placeholder: 'e.g. 70'
                    },
                    action: {
                        label: 'Latest action',
                        bet: 'Bet',
                        raise: 'Raise',
                        call: 'Call',
                        check: 'Check',
                        amount: 'Action amount',
                        pot: 'Pot before action'
                    },
                    notes: {
                        label: 'Notes',
                        placeholder: 'e.g. C-bets flop, tight river calls'
                    },
                    insights: {
                        heading: 'Opponent Insights',
                        aggression: 'Aggression Index',
                        betting: 'Betting Pressure',
                        psychology: 'Psychological Pressure',
                        range: 'Range Advantage'
                    }
                },
                status: {
                    apiLabel: 'API',
                    checking: 'checking…',
                    connected: 'online',
                    failed: 'unreachable'
                },
                prompts: {
                    apiBase: 'Enter backend API base URL (https://your-service.onrender.com)',
                    apiBaseInvalid: 'Please enter a valid http(s) URL.',
                    apiBaseCleared: 'API base reset to default.'
                },
                deck: {
                    heading: 'Deck (click to pick cards)',
                    hint: 'Click an empty slot then choose a card. Used cards grey out; use the ✕ tag to clear a slot.'
                },
                loading: 'Crunching the hand for you...',
                result: {
                    action: 'Recommended Action',
                    confidence: 'Confidence',
                    ev: 'Expected Value'
                },
                factors: {
                    heading: 'Key Factors',
                    names: {
                        equity: 'Equity',
                        pot_odds: 'Pot Odds',
                        hand_strength: 'Hand Strength',
                        position_factor: 'Position',
                        stack_to_pot_ratio: 'SPR',
                        opponent_aggression: 'Opponent Aggression',
                        opponent_tightness: 'Opponent Tightness',
                        betting_pressure: 'Betting Pressure',
                        board_pressure: 'Board Pressure',
                        range_advantage: 'Range Advantage',
                        psychological_pressure: 'Psychological Pressure',
                        bluff_tendency: 'Bluff Tendency',
                        fold_equity: 'Fold Equity',
                        outs: 'Outs',
                        board_wetness: 'Board Texture',
                        effective_stack: 'Effective Stack',
                        draw_probability: 'Draw Probability',
                        implied_odds: 'Implied Odds',
                        pot_commitment: 'Pot Commitment'
                    }
                },
                errors: {
                    missingCards: 'Please select two unique hole cards before running an analysis.',
                    boardRequirement: 'Please provide the correct number of community cards for the selected street.'
                },
                manual: {
                    title: 'Texas Hold\'em Game Manual',
                    basicRules: 'Basic Rules',
                    basicRulesText: 'Texas Hold\'em is a popular poker variant where each player receives 2 hole cards and combines them with 5 community cards to form the best possible 5-card hand.',
                    gameFlow: 'Game Flow',
                    preflop: 'Pre-flop',
                    preflopDesc: 'Each player receives 2 hole cards, decide to call, raise or fold based on hand strength',
                    flop: 'Flop',
                    flopDesc: 'First 3 community cards are dealt, new betting round begins',
                    turn: 'Turn',
                    turnDesc: '4th community card is dealt, continue betting',
                    river: 'River',
                    riverDesc: '5th community card is dealt, final betting round',
                    showdown: 'Showdown',
                    showdownDesc: 'Compare hand rankings, highest hand wins',
                    handRankings: 'Hand Rankings (High to Low)',
                    royalFlush: 'Royal Flush',
                    straightFlush: 'Straight Flush',
                    fourOfKind: 'Four of a Kind',
                    fullHouse: 'Full House',
                    flush: 'Flush',
                    straight: 'Straight',
                    threeOfKind: 'Three of a Kind',
                    twoPair: 'Two Pair',
                    onePair: 'One Pair',
                    highCard: 'High Card',
                    keyConcepts: 'Key Concepts',
                    potOdds: 'Pot Odds',
                    potOddsDesc: 'Ratio of current bet to pot size',
                    impliedOdds: 'Implied Odds',
                    impliedOddsDesc: 'Considering potential future winnings',
                    position: 'Position',
                    positionDesc: 'Relative to dealer button, later position has information advantage',
                    spr: 'Stack-to-Pot Ratio (SPR)',
                    sprDesc: 'Effective stack divided by pot size',
                    draws: 'Draws',
                    drawsDesc: 'Hands that need specific cards to improve',
                    positions: 'Position Guide',
                    positionsIntro: 'In Texas Hold\'em, your position relative to the dealer button determines action order and is crucial for strategy:',
                    earlyPositions: 'Early Position - Act First',
                    utg: 'UTG (Under the Gun)',
                    utgDesc: 'First to act preflop, least information, need strongest hands',
                    utg1: 'UTG+1',
                    utg1Desc: 'Second position to act, still need strong hands',
                    utg2: 'UTG+2',
                    utg2Desc: 'Can slightly widen hand requirements',
                    middlePositions: 'Middle Position',
                    mp1: 'MP1 (Middle Position 1)',
                    mp1Desc: 'Can play more marginal hands',
                    mp2: 'MP2 (Middle Position 2)',
                    mp2Desc: 'Position starts becoming favorable',
                    mp3: 'MP3 (Middle Position 3)',
                    mp3Desc: 'Approaching late position advantages',
                    latePositions: 'Late Position - Information Advantage',
                    lj: 'LJ (Lojack)',
                    ljDesc: 'Can observe early position actions before deciding',
                    hj: 'HJ (Hijack)',
                    hjDesc: 'Very favorable position, can steal blinds',
                    co: 'CO (Cutoff)',
                    coDesc: 'Second best position after button',
                    btn: 'BTN (Button)',
                    btnDesc: 'Always acts last post-flop, best position',
                    blindPositions: 'Blind Positions',
                    sb: 'SB (Small Blind)',
                    sbDesc: 'Acts first post-flop, worst position but half big blind invested',
                    bb: 'BB (Big Blind)',
                    bbDesc: 'Acts last preflop, second post-flop',
                    positionStrategy: 'Position Strategy Tips',
                    tip1: 'Early position needs stronger starting hands as many players act after you',
                    tip2: 'Late position can play more speculative hands, observe opponents first',
                    tip3: 'Button is most profitable position, can raise and steal with wider range',
                    tip4: 'Blind positions are disadvantaged post-flop but consider pot odds with investment',
                    strategies: 'Common Strategy Concepts',
                    tag: 'Tight-Aggressive (TAG)',
                    tagDesc: 'Play strong hands aggressively',
                    lag: 'Loose-Aggressive (LAG)',
                    lagDesc: 'Play more hands aggressively',
                    valueBet: 'Value Bet',
                    valueBetDesc: 'Bet strong hands for value',
                    bluff: 'Bluff',
                    bluffDesc: 'Bet weak hands to make opponents fold',
                    semiBluff: 'Semi-bluff',
                    semiBluffDesc: 'Bet drawing hands that can improve or make opponents fold',
                    startingHands: 'Starting Hands Guide',
                    startingHandsIntro: 'As a beginner, stick to these strong hands to avoid complex decisions:',
                    premiumHands: 'Premium Hands (Play from any position)',
                    strongHands: 'Strong Hands (Play from middle/late position)',
                    speculativeHands: 'Speculative Hands (Late position only)',
                    handTips: '💡 "s" means suited, "o" means offsuit. Beginner tip: Early position = premium hands only, late position = more flexibility.'
                }
            },
            zh: {
                title: 'QPDS',
                subtitle: '量化德州扑克决策辅助系统',
                beginner: {
                    title: '🚀 新手快速入门',
                    intro: '第一次使用？按以下步骤开始：',
                    step1: '选择底牌：点击左边"你的底牌"区域的空槽，然后从下方牌堆选择两张牌',
                    step2: '设置阶段：选择当前游戏阶段（建议新手从"翻前"开始）',
                    step3: '输入参数：设置底池100、跟注20、双方筹码各500',
                    step4: '选择位置：如不确定选择"按钮位(BTN)"',
                    step5: '获取建议：点击"获取决策建议"查看推荐行动',
                    dismiss: '我知道了'
                },
                lesson: {
                    heading: '无限注德州扑克：规则速览',
                    goal: {
                        title: '核心目标',
                        copy: '通过摊牌拿下最大牌力，或迫使所有对手弃牌，赢取底池筹码。'
                    },
                    structure: {
                        title: '完整流程',
                        copy: '每位玩家起手两张底牌，盲注注入底池，公共牌依次翻牌圈、转牌圈、河牌圈亮出，最多四轮下注。'
                    },
                    position: {
                        title: '位置与信息',
                        copy: '按钮位翻牌后最后行动，信息优势最大；盲注位置翻牌后需要优先行动。'
                    },
                    strategy: {
                        title: '量化思维',
                        copy: '胜率、底池赔率、风险偏好共同驱动理性决策，保持纪律避免情绪波动。'
                    },
                    cheatsheet: {
                        title: '牌桌速查宝典',
                        preflop: '翻前口令',
                        preflop1: '按钮位开局 3 倍盲注，用宽范围偷盲',
                        preflop2: '前位紧凶：仅顶级对子 + 强同花连牌',
                        preflop3: '大盲防守：只有牌价 ≥ 3:1 才考虑跟注',
                        flop: '翻牌读牌',
                        flop1: '干燥牌面：中等对子可持续下注压榨超对',
                        flop2: '湿润牌面：优先保护成手，适度缩小下注尺度',
                        flop3: '中顺/同花听牌：补牌数 ×4 ≈ 翻牌后命中率',
                        turn: '转牌决策',
                        turn1: 'SPR < 1.5：强牌可直接推满投入',
                        turn2: '遭遇加注：判断范围优势是否反转',
                        turn3: '半诈唬：确保弃牌率 × 底池 ≥ 本轮成本',
                        river: '河牌执行',
                        river1: '价值下注：确保更弱的牌愿意跟注',
                        river2: '精准诈唬：讲出强牌故事并阻断对手顶牌',
                        river3: '错过听牌：衡量弃牌率和摊牌价值再决定'
                    }
                },
                state: {
                    heading: '牌局设置',
                    hero: '你的底牌',
                    board: '公共牌',
                    parameters: '筹码与参数'
                },
                streets: {
                    PREFLOP: '翻前 (Preflop)',
                    FLOP: '翻牌圈 (Flop)',
                    TURN: '转牌圈 (Turn)',
                    RIVER: '河牌圈 (River)'
                },
                fields: {
                    pot: '底池大小',
                    toCall: '需要跟注',
                    heroStack: '你的筹码',
                    villainStack: '对手筹码',
                    position: '你的位置',
                    villainRange: '对手范围'
                },
                summary: {
                    heading: '当前输入概览',
                    items: {
                        pot: '底池大小',
                        toCall: '跟注金额',
                        heroStack: '你的筹码',
                        villainStack: '对手筹码',
                        street: '当前阶段',
                        position: '你的位置',
                        risk: '风险偏好',
                        opponentModel: '对手画像'
                    }
                },
                placeholders: {
                    pot: '例如 100',
                    toCall: '例如 20',
                    heroStack: '例如 500',
                    villainStack: '例如 500',
                    villainRange: 'AA,KK,QQ,AKs'
                },
                risk: {
                    conservative: '保守',
                    aggressive: '激进'
                },
                buttons: {
                    recommend: '获取决策建议',
                    equity: '仅计算胜率',
                    reset: '重置牌面',
                    gameManual: '🃏 游戏手册',
                    apiConfig: '⚙️ API配置'
                },
                opponent: {
                    heading: '对手建模',
                    aggression: {
                        label: '激进程度',
                        low: '偏被动',
                        high: '超激进'
                    },
                    tightness: {
                        label: '起手范围',
                        wide: '宽松',
                        narrow: '紧实'
                    },
                    bluff: {
                        label: '诈唬频率',
                        low: '罕见',
                        high: '频繁'
                    },
                    confidence: {
                        label: '桌面自信',
                        low: '犹豫',
                        high: '自信'
                    },
                    tilt: {
                        label: '情绪波动',
                        calm: '冷静',
                        hot: '接近失控'
                    },
                    bet: {
                        label: '最近下注占底池%',
                        placeholder: '例如 70'
                    },
                    action: {
                        label: '最近动作',
                        bet: '下注',
                        raise: '加注',
                        call: '跟注',
                        check: '过牌',
                        amount: '动作金额',
                        pot: '行动前底池'
                    },
                    notes: {
                        label: '额外备注',
                        placeholder: '例如：翻牌圈持续下注，河牌趋于紧凶'
                    },
                    insights: {
                        heading: '对手画像',
                        aggression: '激进指数',
                        betting: '下注压力',
                        psychology: '心理压强',
                        range: '范围优势'
                    }
                },
                status: {
                    apiLabel: '后端',
                    checking: '检测中…',
                    connected: '已连接',
                    failed: '无法连接'
                },
                prompts: {
                    apiBase: '请输入后端 API 地址（例如 https://your-service.onrender.com）',
                    apiBaseInvalid: '请输入合法的 http(s) 地址。',
                    apiBaseCleared: '已恢复默认接口地址。'
                },
                deck: {
                    heading: '牌堆（点击选牌）',
                    hint: '先点击空槽再选择卡牌；被选中的卡牌会灰掉，点击槽位右上角的✕即可清除。'
                },
                loading: '正在为你量化牌局...',
                result: {
                    action: '推荐行动',
                    confidence: '置信度',
                    ev: '期望值'
                },
                factors: {
                    heading: '关键因子',
                    names: {
                        equity: '胜率 (Equity)',
                        pot_odds: '底池赔率',
                        hand_strength: '牌力评分',
                        position_factor: '位置优势',
                        stack_to_pot_ratio: 'SPR',
                        opponent_aggression: '对手激进度',
                        opponent_tightness: '对手紧凶度',
                        betting_pressure: '下注压力',
                        board_pressure: '牌面压力',
                        range_advantage: '范围优势',
                        psychological_pressure: '心理压强',
                        bluff_tendency: '诈唬倾向',
                        fold_equity: '弃牌率',
                        outs: '补牌数',
                        board_wetness: '公共牌协调度',
                        effective_stack: '有效筹码',
                        draw_probability: '听牌命中率',
                        implied_odds: '隐含赔率',
                        pot_commitment: '底池投入度'
                    }
                },
                errors: {
                    missingCards: '请先选择两张唯一底牌，再进行分析。',
                    boardRequirement: '当前阶段需要匹配数量的公共牌，请补全或调整阶段。'
                },
                manual: {
                    title: '德州扑克游戏手册',
                    basicRules: '基本规则',
                    basicRulesText: '德州扑克（Texas Hold\'em）是一种流行的扑克变体，每位玩家发2张底牌，通过与5张公共牌结合组成最佳的5张牌型。',
                    gameFlow: '游戏流程',
                    preflop: '翻前（Pre-flop）',
                    preflopDesc: '每位玩家获得2张底牌，根据牌力决定跟注、加注或弃牌',
                    flop: '翻牌（Flop）',
                    flopDesc: '发出前3张公共牌，进行新一轮下注',
                    turn: '转牌（Turn）',
                    turnDesc: '发出第4张公共牌，继续下注',
                    river: '河牌（River）',
                    riverDesc: '发出第5张公共牌，最后一轮下注',
                    showdown: '摊牌（Showdown）',
                    showdownDesc: '比较牌型大小，最大牌型获胜',
                    handRankings: '牌型排名（从大到小）',
                    royalFlush: '皇家同花顺',
                    straightFlush: '同花顺',
                    fourOfKind: '四条',
                    fullHouse: '葫芦',
                    flush: '同花',
                    straight: '顺子',
                    threeOfKind: '三条',
                    twoPair: '两对',
                    onePair: '一对',
                    highCard: '高牌',
                    keyConcepts: '关键概念',
                    potOdds: '底池赔率（Pot Odds）',
                    potOddsDesc: '当前跟注所需筹码与底池大小的比例',
                    impliedOdds: '隐含赔率（Implied Odds）',
                    impliedOddsDesc: '考虑后续可能赢得筹码的赔率',
                    position: '位置（Position）',
                    positionDesc: '相对于庄家位置，后位置有信息优势',
                    spr: '筹码-底池比（SPR）',
                    sprDesc: '有效筹码除以底池大小',
                    draws: '听牌（Draw）',
                    drawsDesc: '需要特定牌才能成牌的牌型',
                    positions: '位置详解',
                    positionsIntro: '在德州扑克中，你相对于庄家按钮的位置决定了行动顺序，是影响策略的关键因素：',
                    earlyPositions: '前位（Early Position）- 最先行动',
                    utg: 'UTG（枪口位）',
                    utgDesc: '翻前第一个行动，信息最少，需要最强的牌',
                    utg1: 'UTG+1',
                    utg1Desc: '第二个行动位置，仍然需要较强手牌',
                    utg2: 'UTG+2',
                    utg2Desc: '可以略微放宽手牌要求',
                    middlePositions: '中位（Middle Position）',
                    mp1: 'MP1（中间位1）',
                    mp1Desc: '可以玩更多边际手牌',
                    mp2: 'MP2（中间位2）',
                    mp2Desc: '位置开始变得有利',
                    mp3: 'MP3（中间位3）',
                    mp3Desc: '接近晚位的优势',
                    latePositions: '后位（Late Position）- 信息优势',
                    lj: 'LJ（劫匪位）',
                    ljDesc: '可以观察前面玩家行动后决策',
                    hj: 'HJ（劫持位）',
                    hjDesc: '非常有利的位置，可以偷盲',
                    co: 'CO（截断位）',
                    coDesc: '仅次于按钮位的优势位置',
                    btn: 'BTN（按钮位）',
                    btnDesc: '翻后永远最后行动，最佳位置',
                    blindPositions: '盲注位（Blind Positions）',
                    sb: 'SB（小盲位）',
                    sbDesc: '翻后第一个行动，位置最差但已投入一半大盲',
                    bb: 'BB（大盲位）',
                    bbDesc: '翻前最后行动，翻后第二个行动',
                    positionStrategy: '位置策略要点',
                    tip1: '前位需要更强的起手牌，因为后面还有很多玩家要行动',
                    tip2: '后位可以玩更多投机性手牌，观察对手行动后再决策',
                    tip3: '按钮位是最有利位置，可以用更宽的范围加注和偷盲',
                    tip4: '盲注位置翻后不利，但翻前已有投入要考虑底池赔率',
                    strategies: '常用策略概念',
                    tag: '紧凶（TAG）',
                    tagDesc: '只玩强牌但玩得激进',
                    lag: '松凶（LAG）',
                    lagDesc: '玩较多牌型且激进下注',
                    valueBet: '价值下注',
                    valueBetDesc: '有强牌时下注获取价值',
                    bluff: '诈唬（Bluff）',
                    bluffDesc: '用弱牌下注迫使对手弃牌',
                    semiBluff: '半诈唬',
                    semiBluffDesc: '用听牌下注，既可能成牌也可能让对手弃牌',
                    startingHands: '新手起手牌建议',
                    startingHandsIntro: '作为新手，建议只玩以下强牌，避免复杂决策：',
                    premiumHands: '顶级强牌（任何位置都可以玩）',
                    strongHands: '强牌（中后位可以玩）',
                    speculativeHands: '投机牌（仅后位考虑）',
                    handTips: '💡 "s"表示同花色，"o"表示不同花色。新手建议：前位只玩顶级强牌，后位可以适当放宽。'
                }
            }
        };

        const positionLabels = {
            BTN: { en: 'Button (BTN)', zh: '按钮位 (BTN)' },
            CO: { en: 'Cutoff (CO)', zh: '截断位 (CO)' },
            HJ: { en: 'Hijack (HJ)', zh: '劫持位 (HJ)' },
            LJ: { en: 'Lojack (LJ)', zh: '劫匪位 (LJ)' },
            MP3: { en: 'Middle Position 3', zh: '中间位3' },
            MP2: { en: 'Middle Position 2', zh: '中间位2' },
            MP1: { en: 'Middle Position 1', zh: '中间位1' },
            UTG2: { en: 'UTG +2', zh: '枪口+2' },
            UTG1: { en: 'UTG +1', zh: '枪口+1' },
            UTG: { en: 'Under the Gun (UTG)', zh: '枪口位 (UTG)' },
            SB: { en: 'Small Blind (SB)', zh: '小盲位 (SB)' },
            BB: { en: 'Big Blind (BB)', zh: '大盲位 (BB)' }
        };

        const streetBoardCounts = {
            PREFLOP: 0,
            FLOP: 3,
            TURN: 4,
            RIVER: 5
        };

        const actionLabels = {
            en: {
                fold: 'Fold',
                check: 'Check',
                call: 'Call',
                raise: 'Raise',
                all_in: 'All-in'
            },
            zh: {
                fold: '弃牌',
                check: '过牌',
                call: '跟注',
                raise: '加注',
                all_in: '全下'
            }
        };

        const suits = [
            { key: 'spades', symbol: '♠', code: 's' },
            { key: 'hearts', symbol: '♥', code: 'h' },
            { key: 'diamonds', symbol: '♦', code: 'd' },
            { key: 'clubs', symbol: '♣', code: 'c' }
        ];

        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];

        const percentFactorKeys = new Set([
            'equity',
            'pot_odds',
            'hand_strength',
            'position_factor',
            'fold_equity',
            'board_wetness',
            'betting_pressure',
            'board_pressure',
            'range_advantage',
            'psychological_pressure',
            'bluff_tendency',
            'opponent_aggression',
            'opponent_tightness',
            'draw_probability',
            'implied_odds',
            'pot_commitment'
        ]);

        const state = {
            language: 'zh',
            heroCards: [null, null],
            board: [null, null, null, null, null],
            street: 'PREFLOP',
            selectedSlot: null,
            position: 'BTN',
            lastResult: null,
            apiStatus: 'idle',
            opponent: {
                aggression: 0.6,
                tightness: 0.5,
                bluff: 0.3,
                confidence: 0.6,
                tilt: 0.4,
                betPct: 65,
                action: {
                    street: 'PREFLOP',
                    type: 'bet',
                    amount: null,
                    pot: null
                },
                notes: ''
            },
            opponentProfile: null
        };

        window.addEventListener('DOMContentLoaded', () => {
            deckGrid = document.getElementById('deckGrid');
            heroSlots = document.getElementById('heroSlots');
            boardSlots = document.getElementById('boardSlots');
            streetOptions = document.getElementById('streetOptions');
            positionSelect = document.getElementById('positionSelect');
            riskSlider = document.getElementById('riskSlider');
            riskValue = document.getElementById('riskValue');
            langToggle = document.getElementById('langToggle');
            apiConfigBtn = document.getElementById('apiConfigBtn');
            apiStatusLabel = document.getElementById('apiStatusLabel');
            loadingIndicator = document.getElementById('loading');
            actionValue = document.getElementById('actionValue');
            confidenceValue = document.getElementById('confidenceValue');
            evValue = document.getElementById('evValue');
            resultBanner = document.getElementById('resultBanner');
            explanationBox = document.getElementById('explanationBox');
            factorsGrid = document.getElementById('factorsGrid');
            errorBox = document.getElementById('errorBox');
            summaryGrid = document.getElementById('summaryGrid');
            opponentInsightsPanel = document.getElementById('opponentInsights');
            opponentArchetype = document.getElementById('opponentArchetype');
            opponentSummary = document.getElementById('opponentSummary');
            opponentNotesContainer = document.getElementById('opponentNotes');
            opponentAggressionMetric = document.getElementById('opponentAggressionMetric');
            opponentBettingMetric = document.getElementById('opponentBettingMetric');
            opponentPsychologyMetric = document.getElementById('opponentPsychologyMetric');
            opponentRangeMetric = document.getElementById('opponentRangeMetric');
            opAggressionInput = document.getElementById('opAggressionInput');
            opTightnessInput = document.getElementById('opTightnessInput');
            opBluffInput = document.getElementById('opBluffInput');
            opConfidenceInput = document.getElementById('opConfidenceInput');
            opTiltInput = document.getElementById('opTiltInput');
            opBetPctInput = document.getElementById('opBetPctInput');
            opActionStreet = document.getElementById('opActionStreet');
            opActionType = document.getElementById('opActionType');
            opActionAmount = document.getElementById('opActionAmount');
            opActionPot = document.getElementById('opActionPot');
            opNotesInput = document.getElementById('opNotesInput');
            opAggressionValue = document.getElementById('opAggressionValue');
            opTightnessValue = document.getElementById('opTightnessValue');
            opBluffValue = document.getElementById('opBluffValue');
            opConfidenceValue = document.getElementById('opConfidenceValue');
            opTiltValue = document.getElementById('opTiltValue');

            // 游戏手册相关元素
            const gameManualBtn = document.getElementById('gameManualBtn');
            const gameManualModal = document.getElementById('gameManualModal');
            const closeManualBtn = document.getElementById('closeManualBtn');

            // 新手提示相关元素
            const beginnerTip = document.getElementById('beginnerTip');
            const dismissTip = document.getElementById('dismissTip');

            // 检查是否是第一次访问
            const hasVisited = localStorage.getItem('qpds_visited');
            if (hasVisited) {
                beginnerTip.classList.add('hidden');
            }

            // 新手提示关闭事件
            dismissTip.addEventListener('click', () => {
                beginnerTip.classList.add('hidden');
                localStorage.setItem('qpds_visited', 'true');
            });

            // 游戏手册事件监听
            gameManualBtn.addEventListener('click', () => {
                gameManualModal.classList.add('show');
            });

            closeManualBtn.addEventListener('click', () => {
                gameManualModal.classList.remove('show');
            });

            // 点击模态框背景关闭
            gameManualModal.addEventListener('click', (e) => {
                if (e.target === gameManualModal) {
                    gameManualModal.classList.remove('show');
                }
            });

            // ESC键关闭模态框
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && gameManualModal.classList.contains('show')) {
                    gameManualModal.classList.remove('show');
                }
            });

            bootstrap();
        });

        function t(key) {
            const parts = key.split('.');
            let cursor = translations[state.language];
            for (const part of parts) {
                if (cursor && part in cursor) {
                    cursor = cursor[part];
                } else {
                    return key;
                }
            }
            return cursor;
        }

        function translatePage() {
            document.documentElement.lang = state.language;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const text = t(key);
                if (typeof text === 'string') {
                    el.textContent = text;
                }
            });

            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                const text = t(key);
                if (typeof text === 'string') {
                    el.setAttribute('placeholder', text);
                }
            });

            // Re-translate stage labels
            streetOptions.querySelectorAll('label').forEach(label => {
                const street = label.getAttribute('data-street');
                const span = label.querySelector('span');
                if (span) {
                    span.textContent = t(`streets.${street}`);
                }
            });

            // Rebuild position select options
            const selected = positionSelect.value;
            positionSelect.innerHTML = '';
            Object.entries(positionLabels).forEach(([value, labels]) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = labels[state.language];
                if (value === selected) {
                    option.selected = true;
                }
                positionSelect.appendChild(option);
            });

            langToggle.textContent = state.language === 'en' ? '中文' : 'English';

            refreshSummary();

            if (state.lastResult) {
                const snapshot = state.lastResult;
                if (snapshot.kind === 'recommendation') {
                    showRecommendation(snapshot.data);
                } else if (snapshot.kind === 'equity') {
                    showEquityOnly(snapshot.data);
                }
            }

            updateApiStatusLabel();
        }

        function getStatusCopy() {
            const fallback = {
                apiLabel: 'API',
                checking: 'checking…',
                connected: 'online',
                failed: 'unreachable'
            };
            return (translations[state.language] && translations[state.language].status) || fallback;
        }

        function updateApiStatusLabel(statusOverride) {
            if (!apiStatusLabel) {
                return;
            }
            const copy = getStatusCopy();
            const status = statusOverride || state.apiStatus;
            let suffix = '';
            if (status === 'checking') {
                suffix = copy.checking;
            } else if (status === 'ok') {
                suffix = copy.connected;
            } else if (status === 'error') {
                suffix = copy.failed;
            }

            const parts = [`${copy.apiLabel}: ${API_URL}`];
            if (suffix) {
                parts.push(`(${suffix})`);
            }
            apiStatusLabel.textContent = parts.join(' ');
        }

        function getBackendUnavailableMessage() {
            if (state.language === 'zh') {
                return `无法连接后端服务：${API_URL}。请启动本地 Flask 后端，或点击“⚙️ API配置”按钮设置已部署的地址。`;
            }
            return `Cannot reach backend service at ${API_URL}. Start the local Flask backend or use the ⚙️ API button to point to your deployed service.`;
        }

        function initApiConfig() {
            if (!apiConfigBtn) {
                return;
            }
            apiConfigBtn.addEventListener('click', () => {
                const promptMessage = t('prompts.apiBase');
                const input = window.prompt(promptMessage, API_URL);
                if (input === null) {
                    return;
                }

                const trimmed = input.trim();
                if (!trimmed) {
                    localStorage.removeItem(API_STORAGE_KEY);
                    API_URL = resolveApiUrl({ skipQuery: true });
                    state.apiStatus = 'idle';
                    updateApiStatusLabel();
                    window.alert(t('prompts.apiBaseCleared'));
                    initHealthCheck({ silent: true });
                    return;
                }

                const sanitized = sanitizeApiUrl(trimmed);
                if (!sanitized) {
                    window.alert(t('prompts.apiBaseInvalid'));
                    return;
                }

                API_URL = sanitized;
                localStorage.setItem(API_STORAGE_KEY, API_URL);
                state.apiStatus = 'checking';
                updateApiStatusLabel('checking');
                initHealthCheck();
            });

            updateApiStatusLabel();
        }

        function buildDeck() {
            deckGrid.innerHTML = '';
            suits.forEach(suit => {
                const row = document.createElement('div');
                row.className = 'deck-row';
                row.dataset.suit = suit.key;

                const label = document.createElement('div');
                label.className = 'deck-suit';
                label.textContent = suit.symbol;
                row.appendChild(label);
                ranks.forEach(rank => {
                    const cardCode = `${rank}${suit.code}`;
                    const button = document.createElement('button');
                    button.className = 'card-button';
                    button.dataset.card = `${rank}${suit.code}`;
                    button.dataset.suit = suit.key;
                    button.innerHTML = `${rank}${suit.symbol}`;
                    button.addEventListener('click', () => onDeckCardSelected(cardCode));
                    row.appendChild(button);
                });
                deckGrid.appendChild(row);
            });
            updateDeckAvailability();
        }

        function createSlotElement(type, index, cardCode) {
            const slot = document.createElement('div');
            slot.className = 'card-slot';
            slot.dataset.type = type;
            slot.dataset.index = index;
            const disabled = type === 'board' && index >= streetBoardCounts[state.street];
            slot.dataset.disabled = disabled ? 'true' : 'false';
            if (disabled) {
                return slot;
            }

            const label = document.createElement('span');
            label.className = 'card-label';
            label.textContent = type === 'hero' ? `P${index + 1}` : `B${index + 1}`;
            slot.appendChild(label);

            if (cardCode) {
                slot.dataset.filled = 'true';
                slot.textContent = cardCode.toUpperCase();
                slot.appendChild(label);

                const tag = document.createElement('div');
                tag.className = 'remove-tag';
                tag.textContent = '✕';
                tag.addEventListener('click', (event) => {
                    event.stopPropagation();
                    clearSlot(type, index);
                });
                slot.appendChild(tag);
            } else {
                slot.dataset.filled = 'false';
                slot.appendChild(label);
            }

            if (state.selectedSlot && state.selectedSlot.type === type && state.selectedSlot.index === index) {
                slot.dataset.selected = 'true';
            }

            slot.addEventListener('click', () => onSlotClick(type, index));
            return slot;
        }

        function renderSlots() {
            heroSlots.innerHTML = '';
            state.heroCards.forEach((card, index) => {
                heroSlots.appendChild(createSlotElement('hero', index, card));
            });

            boardSlots.innerHTML = '';
            state.board.forEach((card, index) => {
                boardSlots.appendChild(createSlotElement('board', index, card));
            });

            refreshSummary();
        }

        function onSlotClick(type, index) {
            const disabled = type === 'board' && index >= streetBoardCounts[state.street];
            if (disabled) {
                return;
            }

            const currentCard = type === 'hero' ? state.heroCards[index] : state.board[index];
            if (currentCard) {
                clearSlot(type, index);
                return;
            }

            state.selectedSlot = { type, index };
            renderSlots();
        }

        function clearSlot(type, index) {
            if (type === 'hero') {
                state.heroCards[index] = null;
            } else {
                state.board[index] = null;
            }
            if (state.selectedSlot && state.selectedSlot.type === type && state.selectedSlot.index === index) {
                state.selectedSlot = null;
            }
            updateDeckAvailability();
            renderSlots();
        }

        function isCardUsed(cardCode) {
            const allCards = [...state.heroCards, ...state.board];
            return allCards.includes(cardCode.toLowerCase());
        }

        function findNextAvailableSlot() {
            for (let i = 0; i < state.heroCards.length; i += 1) {
                if (!state.heroCards[i]) {
                    return { type: 'hero', index: i };
                }
            }
            const allowedBoard = streetBoardCounts[state.street];
            for (let i = 0; i < allowedBoard; i += 1) {
                if (!state.board[i]) {
                    return { type: 'board', index: i };
                }
            }
            return null;
        }

        function onDeckCardSelected(cardCode) {
            if (isCardUsed(cardCode)) {
                return;
            }

            let targetSlot = state.selectedSlot;
            if (!targetSlot) {
                targetSlot = findNextAvailableSlot();
            }
            if (!targetSlot) {
                return;
            }

            if (targetSlot.type === 'hero') {
                state.heroCards[targetSlot.index] = cardCode.toLowerCase();
            } else {
                state.board[targetSlot.index] = cardCode.toLowerCase();
            }

            state.selectedSlot = findNextAvailableSlot();
            updateDeckAvailability();
            renderSlots();
        }

        function updateDeckAvailability() {
            const used = new Set([...state.heroCards, ...state.board].filter(Boolean));
            deckGrid.querySelectorAll('.card-button').forEach(button => {
                const code = (button.dataset.card || '').toLowerCase();
                button.dataset.used = used.has(code) ? 'true' : 'false';
            });
        }

        function onStreetChange(value) {
            state.street = value;
            // Trim board cards beyond allowed count
            const allowed = streetBoardCounts[value];
            state.board = state.board.map((card, index) => (index < allowed ? card : null));
            if (state.selectedSlot && state.selectedSlot.type === 'board' && state.selectedSlot.index >= allowed) {
                state.selectedSlot = null;
            }
            renderSlots();
        }

        function resetBoardSelections() {
            state.heroCards = [null, null];
            state.board = [null, null, null, null, null];
            state.street = 'PREFLOP';
            state.selectedSlot = null;
            streetOptions.querySelectorAll('label').forEach(label => {
                label.classList.toggle('active', label.getAttribute('data-street') === 'PREFLOP');
                label.querySelector('input').checked = label.getAttribute('data-street') === 'PREFLOP';
            });
            renderSlots();
            updateDeckAvailability();
            clearResult();
            showError('');
            state.opponent = {
                aggression: 0.6,
                tightness: 0.5,
                bluff: 0.3,
                confidence: 0.6,
                tilt: 0.4,
                betPct: 65,
                action: {
                    street: 'PREFLOP',
                    type: 'bet',
                    amount: null,
                    pot: null
                },
                notes: ''
            };
            if (opAggressionInput) {
                opAggressionInput.value = 6;
                opAggressionInput.dispatchEvent(new Event('input'));
            }
            if (opTightnessInput) {
                opTightnessInput.value = 5;
                opTightnessInput.dispatchEvent(new Event('input'));
            }
            if (opBluffInput) {
                opBluffInput.value = 3;
                opBluffInput.dispatchEvent(new Event('input'));
            }
            if (opConfidenceInput) {
                opConfidenceInput.value = 6;
                opConfidenceInput.dispatchEvent(new Event('input'));
            }
            if (opTiltInput) {
                opTiltInput.value = 4;
                opTiltInput.dispatchEvent(new Event('input'));
            }
            if (opBetPctInput) {
                opBetPctInput.value = 65;
                opBetPctInput.dispatchEvent(new Event('input'));
            }
            if (opActionStreet) {
                opActionStreet.value = 'PREFLOP';
                opActionStreet.dispatchEvent(new Event('change'));
            }
            if (opActionType) {
                opActionType.value = 'bet';
                opActionType.dispatchEvent(new Event('change'));
            }
            if (opActionAmount) {
                opActionAmount.value = '';
                opActionAmount.dispatchEvent(new Event('input'));
            }
            if (opActionPot) {
                opActionPot.value = '';
                opActionPot.dispatchEvent(new Event('input'));
            }
            if (opNotesInput) {
                opNotesInput.value = '';
                state.opponent.notes = '';
            }
            refreshSummary();
        }

        function buildOpponentObservationPayload() {
            const { action } = state.opponent;
            if (!action || !action.street || !action.type) {
                return null;
            }
            const payload = {
                street: action.street,
                action: action.type
            };
            if (Number.isFinite(action.amount) && Number.isFinite(action.pot) && action.pot > 0) {
                payload.amount = action.amount;
                payload.pot = action.pot;
            }
            return payload;
        }

        function getOpponentStatsPayload() {
            const stats = {
                aggression: state.opponent.aggression,
                tightness: state.opponent.tightness,
                bluff_frequency: state.opponent.bluff,
                recent_bet_pct: state.opponent.betPct,
                confidence: state.opponent.confidence,
                tilt: state.opponent.tilt
            };

            const observation = buildOpponentObservationPayload();
            if (observation) {
                stats.observations = [observation];
            }

            if (state.opponent.notes && state.opponent.notes.trim()) {
                stats.notes = state.opponent.notes.trim();
            }

            return stats;
        }

        function buildOpponentPreviousActions() {
            const observation = buildOpponentObservationPayload();
            if (!observation || observation.amount === undefined) {
                return null;
            }
            return [{
                actor: 'villain',
                street: observation.street,
                action: observation.action,
                amount: observation.amount,
                pot: observation.pot
            }];
        }

        function gatherGameState() {
            const opponentStats = getOpponentStatsPayload();
            const previousActions = buildOpponentPreviousActions();

            const payload = {
                hero_cards: state.heroCards.filter(Boolean).map(card => card.toUpperCase()),
                board: state.board.filter((card, index) => index < streetBoardCounts[state.street] && card).map(card => card.toUpperCase()),
                pot_size: parseFloat(document.getElementById('potInput').value) || 0,
                to_call: parseFloat(document.getElementById('toCallInput').value) || 0,
                hero_stack: parseFloat(document.getElementById('heroStackInput').value) || 0,
                villain_stack: parseFloat(document.getElementById('villainStackInput').value) || 0,
                position: positionSelect.value,
                street: state.street,
                villain_range: document.getElementById('rangeInput').value || null,
                risk_preference: parseFloat(riskSlider.value) || 5,
                opponent_stats: opponentStats
            };

            if (previousActions) {
                payload.previous_actions = previousActions;
            }

            return payload;
        }

        function showLoading() {
            loadingIndicator.classList.add('active');
            resultBanner.style.display = 'none';
            explanationBox.style.display = 'none';
            factorsGrid.innerHTML = '';
        }

        function hideLoading() {
            loadingIndicator.classList.remove('active');
        }

        function clearResult() {
            resultBanner.style.display = 'none';
            explanationBox.style.display = 'none';
            factorsGrid.innerHTML = '';
            confidenceValue.textContent = '-';
            evValue.textContent = '-';
            state.lastResult = null;
            if (opponentInsightsPanel) {
                opponentInsightsPanel.style.display = 'none';
                if (opponentArchetype) opponentArchetype.textContent = '';
                if (opponentSummary) opponentSummary.textContent = '';
                if (opponentAggressionMetric) opponentAggressionMetric.textContent = '-';
                if (opponentBettingMetric) opponentBettingMetric.textContent = '-';
                if (opponentPsychologyMetric) opponentPsychologyMetric.textContent = '-';
                if (opponentRangeMetric) opponentRangeMetric.textContent = '-';
                if (opponentNotesContainer) opponentNotesContainer.innerHTML = '';
            }
            state.opponentProfile = null;
        }

        function formatPercent(value, digits = 1) {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                return '-';
            }
            return `${(value * 100).toFixed(digits)}%`;
        }

        function formatFactorValue(key, value) {
            if (value === null || value === undefined) {
                return '-';
            }
            if (percentFactorKeys.has(key)) {
                return formatPercent(value);
            }
            if (key === 'outs') {
                return `${Math.round(value)}`;
            }
            return `${Number(value).toFixed(2)}`;
        }

        function displayFactors(factors) {
            if (!factors) {
                return;
            }
            const keys = [
                'equity',
                'hand_strength',
                'range_advantage',
                'opponent_aggression',
                'opponent_tightness',
                'betting_pressure',
                'board_wetness',
                'board_pressure',
                'psychological_pressure',
                'fold_equity',
                'bluff_tendency',
                'pot_odds',
                'position_factor',
                'stack_to_pot_ratio',
                'effective_stack',
                'implied_odds',
                'pot_commitment',
                'outs',
                'draw_probability'
            ];
            factorsGrid.innerHTML = '';
            keys.forEach(key => {
                if (factors[key] === undefined) {
                    return;
                }
                const card = document.createElement('div');
                card.className = 'factor-card';

                const name = document.createElement('div');
                name.className = 'factor-name';
                const factorName = translations[state.language].factors.names[key] || key;
                name.textContent = factorName;

                const value = document.createElement('div');
                value.className = 'factor-value';
                value.textContent = formatFactorValue(key, factors[key]);

                card.appendChild(name);
                card.appendChild(value);
                factorsGrid.appendChild(card);
            });
        }

        function renderOpponentInsights(profile, factors) {
            if (!opponentInsightsPanel) {
                return;
            }

            let resolved = profile;
            if (!resolved && factors) {
                resolved = {
                    classification: factors.opponent_classification,
                    summary: factors.opponent_summary,
                    notes: factors.opponent_notes,
                    aggression_index: factors.opponent_aggression,
                    betting_pressure: factors.betting_pressure,
                    psychological_pressure: factors.psychological_pressure,
                    range_advantage: factors.range_advantage
                };
            }

            if (!resolved || (!resolved.classification && !resolved.summary)) {
                opponentInsightsPanel.style.display = 'none';
                state.opponentProfile = null;
                return;
            }

            state.opponentProfile = resolved;
            opponentInsightsPanel.style.display = 'block';

            if (opponentArchetype) {
                opponentArchetype.textContent = resolved.classification || '';
            }
            if (opponentSummary) {
                opponentSummary.textContent = resolved.summary || '';
            }
            if (opponentAggressionMetric) {
                opponentAggressionMetric.textContent = formatPercent(resolved.aggression_index ?? factors?.opponent_aggression ?? 0, 1);
            }
            if (opponentBettingMetric) {
                opponentBettingMetric.textContent = formatPercent(resolved.betting_pressure ?? factors?.betting_pressure ?? 0, 1);
            }
            if (opponentPsychologyMetric) {
                opponentPsychologyMetric.textContent = formatPercent(resolved.psychological_pressure ?? factors?.psychological_pressure ?? 0, 1);
            }
            if (opponentRangeMetric) {
                opponentRangeMetric.textContent = formatPercent(resolved.range_advantage ?? factors?.range_advantage ?? 0, 1);
            }

            if (opponentNotesContainer) {
                opponentNotesContainer.innerHTML = '';
                const notes = [];
                if (Array.isArray(resolved.notes)) {
                    notes.push(...resolved.notes);
                } else if (resolved.notes) {
                    notes.push(resolved.notes);
                }
                if (factors?.opponent_notes && Array.isArray(factors.opponent_notes)) {
                    notes.push(...factors.opponent_notes);
                }

                if (notes.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'insight-note';
                    empty.textContent = state.language === 'zh' ? '暂无更多线索，保持观察。' : 'No additional reads yet — keep observing.';
                    opponentNotesContainer.appendChild(empty);
                } else {
                    notes.slice(0, 4).forEach(note => {
                        const item = document.createElement('div');
                        item.className = 'insight-note';
                        item.textContent = note;
                        opponentNotesContainer.appendChild(item);
                    });
                }
            }
        }

        function getNumericValue(id) {
            const el = document.getElementById(id);
            if (!el) {
                return 0;
            }
            return parseFloat(el.value) || 0;
        }

        function formatChips(amount) {
            const fixed = Number(amount).toFixed(2);
            return fixed.replace(/\.00$/, '');
        }

        function refreshSummary() {
            if (!summaryGrid) {
                return;
            }

            const summaryLabels = translations[state.language].summary.items;
            const summaryData = [
                { key: 'pot', value: formatChips(getNumericValue('potInput')) },
                { key: 'toCall', value: formatChips(getNumericValue('toCallInput')) },
                { key: 'heroStack', value: formatChips(getNumericValue('heroStackInput')) },
                { key: 'villainStack', value: formatChips(getNumericValue('villainStackInput')) },
                { key: 'street', value: t(`streets.${state.street}`) },
                { key: 'position', value: positionLabels[state.position][state.language] },
                { key: 'risk', value: `${riskSlider ? riskSlider.value : 5}/10` },
                { key: 'opponentModel', value: getOpponentSummaryText() }
            ];

            summaryGrid.innerHTML = '';

            summaryData.forEach(({ key, value }) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'summary-item';

                const label = document.createElement('span');
                label.textContent = summaryLabels[key] || key;

                const strong = document.createElement('strong');
                strong.textContent = value;

                wrapper.appendChild(label);
                wrapper.appendChild(strong);
                summaryGrid.appendChild(wrapper);
            });
        }

        function getOpponentSummaryText() {
            const aggressionScore = Math.round((state.opponent.aggression || 0) * 10);
            const tightnessScore = Math.round((state.opponent.tightness || 0) * 10);
            if (state.language === 'zh') {
                return `激进 ${aggressionScore}/10｜范围 ${tightnessScore}/10`;
            }
            return `Agg ${aggressionScore}/10 · Range ${tightnessScore}/10`;
        }

        function translateAction(action) {
            if (!action) {
                return '-';
            }
            const key = action.toLowerCase();
            return actionLabels[state.language][key] || action.toUpperCase();
        }

        function showRecommendation(data) {
            state.lastResult = { kind: 'recommendation', data };
            const actionText = translateAction(data.action);
            if (data.amount && data.action && data.action.toLowerCase() === 'raise' && Number(data.amount) > 0) {
                actionValue.textContent = `${actionText} ${formatChips(data.amount)}`;
            } else {
                actionValue.textContent = actionText;
            }

            if (typeof data.confidence === 'number') {
                confidenceValue.textContent = `${(data.confidence * 100).toFixed(1)}%`;
            } else {
                confidenceValue.textContent = '-';
            }

            if (typeof data.expected_value === 'number') {
                evValue.textContent = formatChips(data.expected_value);
            } else {
                evValue.textContent = '-';
            }

            resultBanner.style.display = 'block';

            if (data.explanation) {
                explanationBox.textContent = data.explanation;
                explanationBox.style.display = 'block';
            } else {
                explanationBox.style.display = 'none';
            }

            displayFactors(data.all_factors || data.factors_used);
            renderOpponentInsights(data.opponent_profile, data.all_factors);
            refreshSummary();
        }

        function showEquityOnly(data) {
            state.lastResult = { kind: 'equity', data };
            const percent = data.win_percentage ? data.win_percentage.toFixed(1) : (data.equity ? (data.equity * 100).toFixed(1) : '-');
            actionValue.textContent = `${percent}%`;
            confidenceValue.textContent = '-';
            evValue.textContent = '-';
            resultBanner.style.display = 'block';
            explanationBox.textContent = state.language === 'zh' ? '当前手牌对输入范围的胜率' : 'Win probability versus the selected range';
            explanationBox.style.display = 'block';
            factorsGrid.innerHTML = '';
            renderOpponentInsights(data.opponent_profile || null, null);
            refreshSummary();
        }

        function showError(message) {
            if (!message) {
                errorBox.textContent = '';
                errorBox.classList.remove('active');
                return;
            }
            errorBox.textContent = message;
            errorBox.classList.add('active');
        }

        function validateBeforeRequest() {
            if (state.heroCards.filter(Boolean).length !== 2) {
                showError(t('errors.missingCards'));
                return false;
            }
            const requiredBoard = streetBoardCounts[state.street];
            if (state.board.filter(Boolean).length !== requiredBoard) {
                showError(t('errors.boardRequirement'));
                return false;
            }
            showError('');
            return true;
        }

        async function request(endpoint, payload) {
            try {
                const response = await fetch(`${API_URL}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    state.apiStatus = 'ok';
                    updateApiStatusLabel('ok');
                    const errorData = await response.json().catch(() => ({}));
                    const message = errorData.error || `HTTP ${response.status}`;
                    throw new Error(message);
                }

                state.apiStatus = 'ok';
                updateApiStatusLabel('ok');
                return response.json();
            } catch (error) {
                if (error instanceof TypeError || error.message === 'Failed to fetch') {
                    state.apiStatus = 'error';
                    updateApiStatusLabel('error');
                    throw new Error(getBackendUnavailableMessage());
                }
                throw error;
            }
        }

        function localizeBackendMessage(message) {
            if (state.language === 'zh') {
                if (message.includes('exactly two hero cards')) {
                    return '德州扑克规则要求你必须持有两张不同的底牌。';
                }
                if (message.includes('Duplicate cards')) {
                    return '出现重复卡牌，请重新选择。';
                }
                if (message.includes('community cards cannot exceed five')) {
                    return '公共牌最多只能有五张。';
                }
                if (message.includes('requires exactly')) {
                    return '当前阶段的公共牌数量不匹配，请核对阶段和牌面。';
                }
            }
            return message;
        }

        async function handleRecommendation() {
            if (!validateBeforeRequest()) {
                return;
            }
            showLoading();
            try {
                const payload = gatherGameState();
                const data = await request('/api/get_recommendation', payload);
                showRecommendation(data);
            } catch (error) {
                showError(localizeBackendMessage(error.message));
            } finally {
                hideLoading();
            }
        }

        async function handleEquityOnly() {
            if (state.heroCards.filter(Boolean).length !== 2) {
                showError(t('errors.missingCards'));
                return;
            }
            showLoading();
            try {
                const payload = gatherGameState();
                const data = await request('/api/get_equity', {
                    hero_cards: payload.hero_cards,
                    board: payload.board,
                    villain_range: payload.villain_range,
                    num_opponents: 1,
                    iterations: 10000
                });
                showEquityOnly(data);
            } catch (error) {
                showError(localizeBackendMessage(error.message));
            } finally {
                hideLoading();
            }
        }

        function initPositionSelect() {
            Object.entries(positionLabels).forEach(([value, labels]) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = labels[state.language];
                positionSelect.appendChild(option);
            });
            positionSelect.value = state.position;

            positionSelect.addEventListener('change', () => {
                state.position = positionSelect.value;
                refreshSummary();
            });
        }

        function initStreetOptions() {
            streetOptions.addEventListener('change', (event) => {
                if (event.target && event.target.name === 'street') {
                    const value = event.target.value;
                    streetOptions.querySelectorAll('label').forEach(label => {
                        label.classList.toggle('active', label.getAttribute('data-street') === value);
                    });
                    onStreetChange(value);
                }
            });
        }

        function initDeckAndSlots() {
            renderSlots();
            buildDeck();
        }

        function initNumericInputs() {
            ['potInput', 'toCallInput', 'heroStackInput', 'villainStackInput'].forEach(id => {
                const el = document.getElementById(id);
                if (!el) {
                    return;
                }
                el.addEventListener('input', refreshSummary);
            });
        }

        function initLanguageToggle() {
            langToggle.addEventListener('click', () => {
                state.language = state.language === 'en' ? 'zh' : 'en';
                translatePage();
                renderSlots();
            });
        }

        function initButtons() {
            document.getElementById('recommendButton').addEventListener('click', handleRecommendation);
            document.getElementById('equityButton').addEventListener('click', handleEquityOnly);
            document.getElementById('resetButton').addEventListener('click', resetBoardSelections);
        }

        function initRiskSlider() {
            riskSlider.addEventListener('input', () => {
                riskValue.textContent = riskSlider.value;
                refreshSummary();
            });

            riskValue.textContent = riskSlider.value;
            refreshSummary();
        }

        function initOpponentControls() {
            if (!opAggressionInput) {
                return;
            }

            const sliderConfigs = [
                { input: opAggressionInput, display: opAggressionValue, key: 'aggression' },
                { input: opTightnessInput, display: opTightnessValue, key: 'tightness' },
                { input: opBluffInput, display: opBluffValue, key: 'bluff' },
                { input: opConfidenceInput, display: opConfidenceValue, key: 'confidence' },
                { input: opTiltInput, display: opTiltValue, key: 'tilt' }
            ];

            sliderConfigs.forEach(({ input, display, key }) => {
                if (!input) {
                    return;
                }
                const apply = () => {
                    const rawValue = Number(input.value || 0);
                    state.opponent[key] = Math.max(0, Math.min(1, rawValue / 10));
                    if (display) {
                        display.textContent = `${rawValue}/10`;
                    }
                    refreshSummary();
                };
                input.addEventListener('input', apply);
                input.value = Math.round((state.opponent[key] || 0) * 10);
                apply();
            });

            if (opBetPctInput) {
                opBetPctInput.value = state.opponent.betPct;
                opBetPctInput.addEventListener('input', () => {
                    const value = Number(opBetPctInput.value || 0);
                    state.opponent.betPct = Math.max(0, Math.min(400, value));
                    refreshSummary();
                });
            }

            if (opActionStreet) {
                opActionStreet.value = state.opponent.action.street;
                opActionStreet.addEventListener('change', () => {
                    state.opponent.action.street = opActionStreet.value;
                    refreshSummary();
                });
            }

            if (opActionType) {
                opActionType.value = state.opponent.action.type;
                opActionType.addEventListener('change', () => {
                    state.opponent.action.type = opActionType.value;
                    refreshSummary();
                });
            }

            if (opActionAmount) {
                opActionAmount.value = state.opponent.action.amount ?? '';
                opActionAmount.addEventListener('input', () => {
                    const value = parseFloat(opActionAmount.value);
                    state.opponent.action.amount = Number.isFinite(value) ? value : null;
                    refreshSummary();
                });
            }

            if (opActionPot) {
                opActionPot.value = state.opponent.action.pot ?? '';
                opActionPot.addEventListener('input', () => {
                    const value = parseFloat(opActionPot.value);
                    state.opponent.action.pot = Number.isFinite(value) ? value : null;
                    refreshSummary();
                });
            }

            if (opNotesInput) {
                opNotesInput.value = state.opponent.notes || '';
                opNotesInput.addEventListener('input', () => {
                    state.opponent.notes = opNotesInput.value;
                    refreshSummary();
                });
            }
        }

        function initHealthCheck(options = {}) {
            const { silent = false } = options;
            state.apiStatus = 'checking';
            updateApiStatusLabel('checking');

            return fetch(`${API_URL}/health`)
                .then((response) => {
                    if (!response.ok) {
                        throw new Error('Health check failed');
                    }
                    state.apiStatus = 'ok';
                    updateApiStatusLabel('ok');
                    if (!silent) {
                        showError('');
                    }
                })
                .catch(() => {
                    state.apiStatus = 'error';
                    updateApiStatusLabel('error');
                    if (!silent) {
                        showError(getBackendUnavailableMessage());
                    }
                });
        }

        function bootstrap() {
            initApiConfig();
            initStreetOptions();
            initPositionSelect();
            initDeckAndSlots();
            initButtons();
            initNumericInputs();
            initRiskSlider();
            initOpponentControls();
            initLanguageToggle();
            translatePage();
            initHealthCheck();
        }
    </script>
</body>
</html>
